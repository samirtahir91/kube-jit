
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">kube-jit/cmd/main.go (0.0%)</option>
				
				<option value="file1">kube-jit/docs/docs.go (100.0%)</option>
				
				<option value="file2">kube-jit/internal/db/db.go (39.4%)</option>
				
				<option value="file3">kube-jit/internal/handlers/admin.go (100.0%)</option>
				
				<option value="file4">kube-jit/internal/handlers/auth.go (96.3%)</option>
				
				<option value="file5">kube-jit/internal/handlers/azure.go (59.2%)</option>
				
				<option value="file6">kube-jit/internal/handlers/common.go (60.7%)</option>
				
				<option value="file7">kube-jit/internal/handlers/get_records.go (90.5%)</option>
				
				<option value="file8">kube-jit/internal/handlers/github.go (43.1%)</option>
				
				<option value="file9">kube-jit/internal/handlers/google.go (21.6%)</option>
				
				<option value="file10">kube-jit/internal/handlers/logger.go (100.0%)</option>
				
				<option value="file11">kube-jit/internal/handlers/openapi.go (100.0%)</option>
				
				<option value="file12">kube-jit/internal/handlers/pending_records.go (98.3%)</option>
				
				<option value="file13">kube-jit/internal/handlers/request.go (52.4%)</option>
				
				<option value="file14">kube-jit/internal/middleware/accesslog.go (100.0%)</option>
				
				<option value="file15">kube-jit/internal/middleware/auth.go (100.0%)</option>
				
				<option value="file16">kube-jit/internal/middleware/logger.go (100.0%)</option>
				
				<option value="file17">kube-jit/internal/middleware/middleware.go (81.8%)</option>
				
				<option value="file18">kube-jit/internal/routes/routes.go (100.0%)</option>
				
				<option value="file19">kube-jit/pkg/email/email.go (0.0%)</option>
				
				<option value="file20">kube-jit/pkg/email/template.go (92.9%)</option>
				
				<option value="file21">kube-jit/pkg/k8s/client.go (33.3%)</option>
				
				<option value="file22">kube-jit/pkg/k8s/config.go (80.0%)</option>
				
				<option value="file23">kube-jit/pkg/k8s/jitgroup.go (54.2%)</option>
				
				<option value="file24">kube-jit/pkg/k8s/logger.go (0.0%)</option>
				
				<option value="file25">kube-jit/pkg/k8s/request.go (100.0%)</option>
				
				<option value="file26">kube-jit/pkg/sessioncookie/logger.go (0.0%)</option>
				
				<option value="file27">kube-jit/pkg/sessioncookie/session_cookie.go (16.9%)</option>
				
				<option value="file28">kube-jit/pkg/utils/hmac.go (94.4%)</option>
				
				<option value="file29">kube-jit/pkg/utils/logger.go (0.0%)</option>
				
				<option value="file30">kube-jit/pkg/utils/securecookie.go (100.0%)</option>
				
				<option value="file31">kube-jit/pkg/utils/utils.go (88.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// @title Kube-JIT API
// @version 1.0
// @description Self-service Kubernetes RBAC JIT Requests with Google/Azure/Github Oauth.
// @BasePath /kube-jit-api
package main

import (
        "encoding/gob"
        "flag"
        "kube-jit/internal/db"
        "kube-jit/internal/handlers"
        "kube-jit/internal/middleware"
        "kube-jit/internal/routes"
        "kube-jit/pkg/k8s"
        "kube-jit/pkg/utils"
        "os"
        "regexp"
        "strconv"
        "time"

        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"

        ginzap "github.com/gin-contrib/zap"
        "github.com/gin-gonic/gin"
)

var logger *zap.Logger

func main() <span class="cov0" title="0">{
        // Read DEBUG_LOG from env var
        debugLog, logVarErr := strconv.ParseBool(os.Getenv("DEBUG_LOG"))
        if logVarErr != nil </span><span class="cov0" title="0">{
                debugLog = false
        }</span>

        <span class="cov0" title="0">var zapCfg zap.Config
        if debugLog </span><span class="cov0" title="0">{
                zapCfg = zap.NewDevelopmentConfig()
        }</span> else<span class="cov0" title="0"> {
                zapCfg = zap.NewProductionConfig()
        }</span>

        // Optional: allow zap to bind flags if you want CLI overrides
        <span class="cov0" title="0">zapCfg.Level = zap.NewAtomicLevelAt(zapcore.InfoLevel)
        flag.Parse()

        var err error
        logger, err = zapCfg.Build()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">defer logger.Sync()

        // Register gob types for db
        gob.Register(map[string]any{})

        // Initialize zap logger in all packages
        handlers.InitLogger(logger)
        db.InitLogger(logger)
        middleware.InitLogger(logger)
        k8s.InitLogger(logger)
        utils.InitLogger(logger)

        // Initialize Kubernetes client and cache
        k8s.InitK8sConfig()

        // Initialize database
        db.InitDB()

        r := gin.New()

        // Skip only authenticated routes and healthz (not oauth, client_id, build-sha, logout)
        rxAuthenticated := regexp.MustCompile(`^/kube-jit-api/(healthz|approving-groups|roles-and-clusters|github/profile|google/profile|azure/profile|submit-request|history|approvals|approve-reject|permissions|admin/clean-expired)$`)
        r.Use(ginzap.GinzapWithConfig(logger, &amp;ginzap.Config{
                UTC:             true,
                TimeFormat:      time.RFC3339,
                SkipPathRegexps: []*regexp.Regexp{rxAuthenticated},
        }))
        r.Use(ginzap.RecoveryWithZap(logger, true))

        // Setup middleware
        middleware.SetupMiddleware(r)

        // Setup routes
        routes.SetupRoutes(r)

        port := utils.MustGetEnv("LISTEN_PORT")
        logger.Info("Starting server", zap.String("port", port))
        if err := r.Run(":" + port); err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to start server", zap.Error(err))
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/admin/clean-expired": {
            "post": {
                "description": "Deletes JIT requests where endDate is in the past and status is \"Requested\" (not Approved or Rejected). Admin only.\nRequires one or more cookies named kube_jit_session_\u003cnumber\u003e (e.g., kube_jit_session_0, kube_jit_session_1).\nPass split cookies in the Cookie header, for example:\n-H \"Cookie: kube_jit_session_0=${cookie_0};kube_jit_session_1=${cookie_1}\"\nNote: Swagger UI cannot send custom Cookie headers due to browser security restrictions. Use curl for testing with split cookies.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "admin"
                ],
                "summary": "Clean up expired non-approved JIT requests",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Session cookies (multiple allowed, names: kube_jit_session_0, kube_jit_session_1, etc.)",
                        "name": "Cookie",
                        "in": "header",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Expired non-approved requests cleaned",
                        "schema": {
                            "$ref": "#/definitions/handlers.CleanExpiredResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized: admin only",
                        "schema": {
                            "$ref": "#/definitions/models.SimpleMessageResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to clean expired requests",
                        "schema": {
                            "$ref": "#/definitions/models.SimpleMessageResponse"
                        }
                    }
                }
            }
        },
        "/approvals": {
            "get": {
                "description": "Returns the pending JIT requests for the authenticated user's approver groups.\nRequires one or more cookies named kube_jit_session_\u003cnumber\u003e (e.g., kube_jit_session_0, kube_jit_session_1).\nPass split cookies in the Cookie header, for example:\n-H \"Cookie: kube_jit_session_0=${cookie_0};kube_jit_session_1=${cookie_1}\"\nNote: Swagger UI cannot send custom Cookie headers due to browser security restrictions. Use curl for testing with split cookies.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "records"
                ],
                "summary": "Get pending JIT requests for approver groups",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Session cookies (multiple allowed, names: kube_jit_session_0, kube_jit_session_1, etc.)",
                        "name": "Cookie",
                        "in": "header",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "List of pending requests",
                        "schema": {
                            "$ref": "#/definitions/handlers.PendingApprovalsResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized: no approver groups in session",
                        "schema": {
                            "$ref": "#/definitions/models.SimpleMessageResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to fetch pending requests",
                        "schema": {
                            "$ref": "#/definitions/models.SimpleMessageResponse"
                        }
                    }
                }
            }
        },
        "/approve-reject": {
            "post": {
                "description": "Approves or rejects pending JIT access requests. Admins and platform approvers can approve/reject multiple requests at once. Non-admins can approve/reject individual namespaces.\nRequires one or more cookies named kube_jit_session_\u003cnumber\u003e (e.g., kube_jit_session_0, kube_jit_session_1).\nPass split cookies in the Cookie header, for example:\n-H \"Cookie: kube_jit_session_0=${cookie_0};kube_jit_session_1=${cookie_1}\"\nNote: Swagger UI cannot send custom Cookie headers due to browser security restrictions. Use curl for testing with split cookies.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "request"
                ],
                "summary": "Approve or reject JIT access requests",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Session cookies (multiple allowed, names: kube_jit_session_0, kube_jit_session_1, etc.)",
                        "name": "Cookie",
                        "in": "header",
                        "required": true
                    },
                    {
                        "description": "Approval/rejection payload (admins/platform approvers use AdminApproveRequest, non-admins use UserApproveRequest)",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handlers.AdminApproveRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Requests processed successfully",
                        "schema": {
                            "$ref": "#/definitions/models.SimpleMessageResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid request format",
                        "schema": {
                            "$ref": "#/definitions/models.SimpleMessageResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized: no approver groups in session",
                        "schema": {
                            "$ref": "#/definitions/models.SimpleMessageResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to process requests",
                        "schema": {
                            "$ref": "#/definitions/models.SimpleMessageResponse"
                        }
                    }
                }
            }
        },
        "/approving-groups": {
            "get": {
                "description": "Returns the list of platform approving groups for the authenticated user.\nRequires one or more cookies named kube_jit_session_\u003cnumber\u003e (e.g., kube_jit_session_0, kube_jit_session_1).\nPass split cookies in the Cookie header, for example:\n-H \"Cookie: kube_jit_session_0=${cookie_0};kube_jit_session_1=${cookie_1}\"\nNote: Swagger UI cannot send custom Cookie headers due to browser security restrictions. Use curl for testing with split cookies.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "records"
                ],
                "summary": "Get platform approving groups",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Session cookies (multiple allowed, names: kube_jit_session_0, kube_jit_session_1, etc.)",
                        "name": "Cookie",
                        "in": "header",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/models.Team"
                            }
                        }
                    },
                    "401": {
                        "description": "Unauthorized: no token in session data",
                        "schema": {
                            "$ref": "#/definitions/models.SimpleMessageResponse"
                        }
                    }
                }
            }
        },
        "/azure/profile": {
            "get": {
                "description": "Returns the normalized Azure user profile for the authenticated user.\nRequires one or more cookies named kube_jit_session_\u003cnumber\u003e (e.g., kube_jit_session_0, kube_jit_session_1).\nPass split cookies in the Cookie header, for example:\n-H \"Cookie: kube_jit_session_0=${cookie_0};kube_jit_session_1=${cookie_1}\"\nNote: Swagger UI cannot send custom Cookie headers due to browser security restrictions. Use curl for testing with split cookies.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "azure"
                ],
                "summary": "Get the logged in user's Azure profile",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Session cookies (multiple allowed, names: kube_jit_session_0, kube_jit_session_1, etc.)",
                        "name": "Cookie",
                        "in": "header",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.NormalizedUserData"
                        }
                    },
                    "401": {
                        "description": "Unauthorized: no token in session data",
                        "schema": {
                            "$ref": "#/definitions/models.SimpleMessageResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/models.SimpleMessageResponse"
                        }
                    }
                }
            }
        },
        "/build-sha": {
            "get": {
                "description": "Returns the current build SHA for the running API.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "health"
                ],
                "summary": "Get build SHA",
                "responses": {
                    "200": {
                        "description": "Current build SHA",
                        "schema": {
                            "$ref": "#/definitions/handlers.BuildShaResponse"
                        }
                    }
                }
            }
        },
        "/client_id": {
            "get": {
                "description": "Returns the OAuth client_id, provider, redirect URI, and auth URL for the frontend to initiate login.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Get OAuth client configuration",
                "responses": {
                    "200": {
                        "description": "OAuth client configuration",
                        "schema": {
                            "$ref": "#/definitions/handlers.OauthClientIdResponse"
                        }
                    }
                }
            }
        },
        "/github/profile": {
            "get": {
                "description": "Returns the normalized GitHub user profile for the authenticated user.\nRequires one or more cookies named kube_jit_session_\u003cnumber\u003e (e.g., kube_jit_session_0, kube_jit_session_1).\nPass split cookies in the Cookie header, for example:\n-H \"Cookie: kube_jit_session_0=${cookie_0};kube_jit_session_1=${cookie_1}\"\nNote: Swagger UI cannot send custom Cookie headers due to browser security restrictions. Use curl for testing with split cookies.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "github"
                ],
                "summary": "Get the logged in user's GitHub profile",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Session cookies (multiple allowed, names: kube_jit_session_0, kube_jit_session_1, etc.)",
                        "name": "Cookie",
                        "in": "header",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.NormalizedUserData"
                        }
                    },
                    "401": {
                        "description": "Unauthorized: no token in session data",
                        "schema": {
                            "$ref": "#/definitions/models.SimpleMessageResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/models.SimpleMessageResponse"
                        }
                    }
                }
            }
        },
        "/google/profile": {
            "get": {
                "description": "Returns the normalized Google user profile for the authenticated user.\nRequires one or more cookies named kube_jit_session_\u003cnumber\u003e (e.g., kube_jit_session_0, kube_jit_session_1).\nPass split cookies in the Cookie header, for example:\n-H \"Cookie: kube_jit_session_0=${cookie_0};kube_jit_session_1=${cookie_1}\"\nNote: Swagger UI cannot send custom Cookie headers due to browser security restrictions. Use curl for testing with split cookies.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "google"
                ],
                "summary": "Get the logged in user's Google profile",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Session cookies (multiple allowed, names: kube_jit_session_0, kube_jit_session_1, etc.)",
                        "name": "Cookie",
                        "in": "header",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.NormalizedUserData"
                        }
                    },
                    "401": {
                        "description": "Unauthorized: no token in session data",
                        "schema": {
                            "$ref": "#/definitions/models.SimpleMessageResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/models.SimpleMessageResponse"
                        }
                    }
                }
            }
        },
        "/healthz": {
            "get": {
                "description": "Returns a simple status message to verify the API is running.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "health"
                ],
                "summary": "Health check endpoint",
                "responses": {
                    "200": {
                        "description": "API is healthy",
                        "schema": {
                            "$ref": "#/definitions/models.SimpleMessageResponse"
                        }
                    }
                }
            }
        },
        "/history": {
            "get": {
                "description": "Returns the latest JIT requests for a user with optional limit and date range.\nRequires one or more cookies named kube_jit_session_\u003cnumber\u003e (e.g., kube_jit_session_0, kube_jit_session_1).\nPass split cookies in the Cookie header, for example:\n-H \"Cookie: kube_jit_session_0=${cookie_0};kube_jit_session_1=${cookie_1}\"\nNote: Swagger UI cannot send custom Cookie headers due to browser security restrictions. Use curl for testing with split cookies:\nLogin required to test via browser, else test via curl",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "records"
                ],
                "summary": "Get JIT requests for a user",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Session cookies (multiple allowed, names: kube_jit_session_0, kube_jit_session_1, etc.)",
                        "name": "Cookie",
                        "in": "header",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "User ID",
                        "name": "userID",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Username",
                        "name": "username",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "description": "Limit",
                        "name": "limit",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/models.RequestWithNamespaceApprovers"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/models.SimpleMessageResponse"
                        }
                    }
                }
            }
        },
        "/k8s-callback": {
            "post": {
                "description": "Used by the downstream Kubernetes controller to callback for status update. Validates the signed URL and updates the request status in the database. Returns a success message.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "k8s"
                ],
                "summary": "Kubernetes controller callback for status update",
                "parameters": [
                    {
                        "description": "Callback payload (ticketID, status, message)",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "object"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Status updated successfully",
                        "schema": {
                            "$ref": "#/definitions/models.SimpleMessageResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid request",
                        "schema": {
                            "$ref": "#/definitions/models.SimpleMessageResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/models.SimpleMessageResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to update request",
                        "schema": {
                            "$ref": "#/definitions/models.SimpleMessageResponse"
                        }
                    }
                }
            }
        },
        "/logout": {
            "post": {
                "description": "Clears all session cookies with the session prefix and logs the user out.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Log out and clear all session cookies",
                "responses": {
                    "200": {
                        "description": "Logged out successfully",
                        "schema": {
                            "$ref": "#/definitions/models.SimpleMessageResponse"
                        }
                    }
                }
            }
        },
        "/oauth/azure/callback": {
            "get": {
                "description": "Handles the Azure OAuth callback, exchanges the code for an access token, fetches user info, sets session data, and returns normalized user data and expiration time.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "azure"
                ],
                "summary": "Azure OAuth callback",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Azure OAuth authorization code",
                        "name": "code",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Normalized user data and expiration time",
                        "schema": {
                            "$ref": "#/definitions/models.LoginResponse"
                        }
                    },
                    "400": {
                        "description": "Missing or invalid code",
                        "schema": {
                            "$ref": "#/definitions/models.SimpleMessageResponse"
                        }
                    },
                    "403": {
                        "description": "Unauthorized domain",
                        "schema": {
                            "$ref": "#/definitions/models.SimpleMessageResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/models.SimpleMessageResponse"
                        }
                    }
                }
            }
        },
        "/oauth/github/callback": {
            "get": {
                "description": "Handles the GitHub OAuth callback, exchanges the code for an access token, fetches user info, sets session data, and returns normalized user data and expiration time.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "github"
                ],
                "summary": "GitHub OAuth callback",
                "parameters": [
                    {
                        "type": "string",
                        "description": "GitHub OAuth authorization code",
                        "name": "code",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Normalized user data and expiration time",
                        "schema": {
                            "$ref": "#/definitions/models.LoginResponse"
                        }
                    },
                    "400": {
                        "description": "Missing or invalid code",
                        "schema": {
                            "$ref": "#/definitions/models.SimpleMessageResponse"
                        }
                    },
                    "403": {
                        "description": "Unauthorized org",
                        "schema": {
                            "$ref": "#/definitions/models.SimpleMessageResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/models.SimpleMessageResponse"
                        }
                    }
                }
            }
        },
        "/oauth/google/callback": {
            "get": {
                "description": "Handles the Google OAuth callback, exchanges the code for an access token, fetches user info, sets session data, and returns normalized user data and expiration time.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "google"
                ],
                "summary": "Google OAuth callback",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Google OAuth authorization code",
                        "name": "code",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Normalized user data and expiration time",
                        "schema": {
                            "$ref": "#/definitions/models.LoginResponse"
                        }
                    },
                    "400": {
                        "description": "Missing or invalid code",
                        "schema": {
                            "$ref": "#/definitions/models.SimpleMessageResponse"
                        }
                    },
                    "403": {
                        "description": "Unauthorized domain",
                        "schema": {
                            "$ref": "#/definitions/models.SimpleMessageResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/models.SimpleMessageResponse"
                        }
                    }
                }
            }
        },
        "/permissions": {
            "post": {
                "description": "Returns the user's permissions and group memberships for the specified provider (GitHub, Google, Azure).\nRequires one or more cookies named kube_jit_session_\u003cnumber\u003e (e.g., kube_jit_session_0, kube_jit_session_1).\nPass split cookies in the Cookie header, for example:\n-H \"Cookie: kube_jit_session_0=${cookie_0};kube_jit_session_1=${cookie_1}\"\nNote: Swagger UI cannot send custom Cookie headers due to browser security restrictions. Use curl for testing with split cookies.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Get common permissions for the logged in user",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Session cookies (multiple allowed, names: kube_jit_session_0, kube_jit_session_1, etc.)",
                        "name": "Cookie",
                        "in": "header",
                        "required": true
                    },
                    {
                        "description": "Provider payload",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handlers.CommonPermissionsRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "User permissions and groups",
                        "schema": {
                            "$ref": "#/definitions/handlers.CommonPermissionsResponse"
                        }
                    },
                    "400": {
                        "description": "Missing or invalid provider",
                        "schema": {
                            "$ref": "#/definitions/models.SimpleMessageResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized: no token in session data",
                        "schema": {
                            "$ref": "#/definitions/models.SimpleMessageResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to fetch user groups",
                        "schema": {
                            "$ref": "#/definitions/models.SimpleMessageResponse"
                        }
                    }
                }
            }
        },
        "/roles-and-clusters": {
            "get": {
                "description": "Returns the list of clusters and roles available to the user.\nRequires one or more cookies named kube_jit_session_\u003cnumber\u003e (e.g., kube_jit_session_0, kube_jit_session_1).\nPass split cookies in the Cookie header, for example:\n-H \"Cookie: kube_jit_session_0=${cookie_0};kube_jit_session_1=${cookie_1}\"\nNote: Swagger UI cannot send custom Cookie headers due to browser security restrictions. Use curl for testing with split cookies.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "records"
                ],
                "summary": "Get available clusters and roles",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Session cookies (multiple allowed, names: kube_jit_session_0, kube_jit_session_1, etc.)",
                        "name": "Cookie",
                        "in": "header",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "clusters and roles",
                        "schema": {
                            "$ref": "#/definitions/handlers.ClustersAndRolesResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized: no token in session data",
                        "schema": {
                            "$ref": "#/definitions/models.SimpleMessageResponse"
                        }
                    }
                }
            }
        },
        "/submit-request": {
            "post": {
                "description": "Creates a new JIT access request for the authenticated user.\nRequires one or more cookies named kube_jit_session_\u003cnumber\u003e (e.g., kube_jit_session_0, kube_jit_session_1).\nPass split cookies in the Cookie header, for example:\n-H \"Cookie: kube_jit_session_0=${cookie_0};kube_jit_session_1=${cookie_1}\"\nNote: Swagger UI cannot send custom Cookie headers due to browser security restrictions. Use curl for testing with split cookies.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "request"
                ],
                "summary": "Submit a new JIT access request",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Session cookies (multiple allowed, names: kube_jit_session_0, kube_jit_session_1, etc.)",
                        "name": "Cookie",
                        "in": "header",
                        "required": true
                    },
                    {
                        "description": "JIT request payload",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handlers.SubmitRequestPayload"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Request submitted successfully",
                        "schema": {
                            "$ref": "#/definitions/models.SimpleMessageResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid request data",
                        "schema": {
                            "$ref": "#/definitions/models.SimpleMessageResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized: no token in session data",
                        "schema": {
                            "$ref": "#/definitions/models.SimpleMessageResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to submit request",
                        "schema": {
                            "$ref": "#/definitions/models.SimpleMessageResponse"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "handlers.AdminApproveRequest": {
            "type": "object",
            "properties": {
                "approverID": {
                    "type": "string"
                },
                "approverName": {
                    "type": "string"
                },
                "requests": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.RequestData"
                    }
                },
                "status": {
                    "type": "string"
                }
            }
        },
        "handlers.BuildShaResponse": {
            "type": "object",
            "properties": {
                "sha": {
                    "type": "string"
                }
            }
        },
        "handlers.CleanExpiredResponse": {
            "type": "object",
            "properties": {
                "deleted": {
                    "type": "integer"
                },
                "message": {
                    "type": "string"
                }
            }
        },
        "handlers.ClustersAndRolesResponse": {
            "type": "object",
            "properties": {
                "clusters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.Roles"
                    }
                }
            }
        },
        "handlers.CommonPermissionsRequest": {
            "type": "object",
            "properties": {
                "provider": {
                    "type": "string",
                    "example": "github"
                }
            }
        },
        "handlers.CommonPermissionsResponse": {
            "type": "object",
            "properties": {
                "adminGroups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.Team"
                    }
                },
                "approverGroups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.Team"
                    }
                },
                "isAdmin": {
                    "type": "boolean"
                },
                "isApprover": {
                    "type": "boolean"
                },
                "isPlatformApprover": {
                    "type": "boolean"
                },
                "platformApproverGroups": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.Team"
                    }
                }
            }
        },
        "handlers.OauthClientIdResponse": {
            "type": "object",
            "properties": {
                "auth_url": {
                    "type": "string"
                },
                "client_id": {
                    "type": "string"
                },
                "provider": {
                    "type": "string"
                },
                "redirect_uri": {
                    "type": "string"
                }
            }
        },
        "handlers.PendingApprovalsResponse": {
            "type": "object",
            "properties": {
                "pendingRequests": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/handlers.PendingRequest"
                    }
                }
            }
        },
        "handlers.PendingRequest": {
            "type": "object",
            "properties": {
                "CreatedAt": {
                    "type": "string"
                },
                "ID": {
                    "type": "integer"
                },
                "approvedList": {
                    "type": "array",
                    "items": {
                        "type": "boolean"
                    }
                },
                "clusterName": {
                    "type": "string"
                },
                "endDate": {
                    "type": "string"
                },
                "groupIDs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "groupNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "justification": {
                    "type": "string"
                },
                "namespaces": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "roleName": {
                    "type": "string"
                },
                "startDate": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                },
                "userID": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                },
                "users": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "handlers.SubmitRequestPayload": {
            "type": "object",
            "properties": {
                "cluster": {
                    "$ref": "#/definitions/models.Cluster"
                },
                "endDate": {
                    "type": "string"
                },
                "justification": {
                    "type": "string"
                },
                "namespaces": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "requestorId": {
                    "type": "string"
                },
                "requestorName": {
                    "type": "string"
                },
                "role": {
                    "$ref": "#/definitions/models.Roles"
                },
                "startDate": {
                    "type": "string"
                },
                "users": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "models.Cluster": {
            "type": "object",
            "properties": {
                "name": {
                    "type": "string"
                }
            }
        },
        "models.LoginResponse": {
            "type": "object",
            "properties": {
                "expiresIn": {
                    "type": "integer"
                },
                "userData": {
                    "$ref": "#/definitions/models.NormalizedUserData"
                }
            }
        },
        "models.NamespaceApprovalInfo": {
            "type": "object",
            "properties": {
                "approved": {
                    "type": "boolean"
                },
                "approverID": {
                    "type": "string"
                },
                "approverName": {
                    "type": "string"
                },
                "groupID": {
                    "type": "string"
                },
                "groupName": {
                    "type": "string"
                },
                "namespace": {
                    "type": "string"
                }
            }
        },
        "models.NormalizedUserData": {
            "type": "object",
            "properties": {
                "avatar_url": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "provider": {
                    "type": "string"
                }
            }
        },
        "models.RequestData": {
            "type": "object",
            "properties": {
                "CreatedAt": {
                    "type": "string"
                },
                "DeletedAt": {
                    "type": "string"
                },
                "ID": {
                    "type": "integer"
                },
                "UpdatedAt": {
                    "type": "string"
                },
                "approverIDs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "approverNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "clusterName": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "endDate": {
                    "type": "string"
                },
                "fullyApproved": {
                    "type": "boolean"
                },
                "justification": {
                    "type": "string"
                },
                "namespaces": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "notes": {
                    "type": "string"
                },
                "roleName": {
                    "type": "string"
                },
                "startDate": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                },
                "userID": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                },
                "users": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "models.RequestWithNamespaceApprovers": {
            "type": "object",
            "properties": {
                "CreatedAt": {
                    "type": "string"
                },
                "DeletedAt": {
                    "type": "string"
                },
                "ID": {
                    "type": "integer"
                },
                "UpdatedAt": {
                    "type": "string"
                },
                "approverIDs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "approverNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "clusterName": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "endDate": {
                    "type": "string"
                },
                "fullyApproved": {
                    "type": "boolean"
                },
                "justification": {
                    "type": "string"
                },
                "namespaceApprovals": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.NamespaceApprovalInfo"
                    }
                },
                "namespaces": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "notes": {
                    "type": "string"
                },
                "roleName": {
                    "type": "string"
                },
                "startDate": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                },
                "userID": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                },
                "users": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "models.Roles": {
            "type": "object",
            "properties": {
                "name": {
                    "type": "string"
                }
            }
        },
        "models.SimpleMessageResponse": {
            "type": "object",
            "properties": {
                "error": {
                    "type": "string"
                },
                "message": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                }
            }
        },
        "models.Team": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "",
        BasePath:         "/kube-jit-api",
        Schemes:          []string{},
        Title:            "Kube-JIT API",
        Description:      "Self-service Kubernetes RBAC JIT Requests with Google/Azure/Github Oauth.",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov8" title="1">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package db

import (
        "fmt"
        "os"
        "strconv"
        "time"

        "kube-jit/internal/models"
        "kube-jit/pkg/utils"

        "go.uber.org/zap"
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
)

var (
        DB     *gorm.DB
        logger *zap.Logger
)

// InitLogger sets the zap logger for this package
func InitLogger(l *zap.Logger) <span class="cov8" title="1">{
        logger = l
}</span>

func InitDB() <span class="cov8" title="1">{
        var err error

        // Read environment variables
        host := utils.MustGetEnv("DB_HOST")
        user := utils.MustGetEnv("DB_USER")
        password := utils.MustGetEnv("DB_PASSWORD")
        dbname := utils.MustGetEnv("DB_NAME")
        port := utils.MustGetEnv("DB_PORT")
        sslmode := utils.MustGetEnv("DB_SSLMODE")
        timezone := utils.MustGetEnv("DB_TIMEZONE")
        connect_timeout := utils.MustGetEnv("DB_CONN_TIMEOUT")

        // Construct DSN
        dsn := fmt.Sprintf("host=%s connect_timeout=%s user=%s password=%s dbname=%s port=%s sslmode=%s TimeZone=%s",
                host, connect_timeout, user, password, dbname, port, sslmode, timezone)

        DB, err = gorm.Open(postgres.Open(dsn), &amp;gorm.Config{})
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to open database connection", zap.Error(err))
        }</span>

        // Enable GORM debug mode if DB_DEBUG=true
        <span class="cov0" title="0">if os.Getenv("DB_DEBUG") == "true" </span><span class="cov0" title="0">{
                DB = DB.Debug()
                logger.Info("GORM debug mode enabled")
        }</span>

        // Configure connection pool
        <span class="cov0" title="0">sqlDB, err := DB.DB()
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to get database connection", zap.Error(err))
        }</span>

        // Read connection pool settings from environment variables
        <span class="cov0" title="0">maxOpenConns, _ := strconv.Atoi(utils.GetEnv("DB_MAX_OPEN_CONNS", "25"))
        maxIdleConns, _ := strconv.Atoi(utils.GetEnv("DB_MAX_IDLE_CONNS", "10"))
        connMaxLifetime, _ := time.ParseDuration(utils.GetEnv("DB_CONN_MAX_LIFETIME", "5m"))
        connMaxIdleTime, _ := time.ParseDuration(utils.GetEnv("DB_CONN_MAX_IDLE_TIME", "10m"))

        sqlDB.SetMaxOpenConns(maxOpenConns)
        sqlDB.SetMaxIdleConns(maxIdleConns)
        sqlDB.SetConnMaxLifetime(connMaxLifetime)
        sqlDB.SetConnMaxIdleTime(connMaxIdleTime)

        logger.Info("Migrating database schema...")
        err = DB.AutoMigrate(&amp;models.RequestData{}, &amp;models.RequestNamespace{})
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Error migrating database", zap.Error(err))
        }</span>

        <span class="cov0" title="0">logger.Info("Database schema migrated successfully")</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package handlers

import (
        "kube-jit/internal/db"
        "kube-jit/internal/models"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// CleanExpiredResponse represents the response for CleanExpiredRequests
type CleanExpiredResponse struct {
        Message string `json:"message"`
        Deleted int64  `json:"deleted"`
}

// CleanExpiredRequests godoc
// @Summary Clean up expired non-approved JIT requests
// @Description Deletes JIT requests where endDate is in the past and status is "Requested" (not Approved or Rejected). Admin only.
// @Description Requires one or more cookies named kube_jit_session_&lt;number&gt; (e.g., kube_jit_session_0, kube_jit_session_1).
// @Description Pass split cookies in the Cookie header, for example:
// @Description     -H "Cookie: kube_jit_session_0=${cookie_0};kube_jit_session_1=${cookie_1}"
// @Description Note: Swagger UI cannot send custom Cookie headers due to browser security restrictions. Use curl for testing with split cookies.
// @Tags admin
// @Accept  json
// @Produce  json
// @Param   Cookie header string true "Session cookies (multiple allowed, names: kube_jit_session_0, kube_jit_session_1, etc.)"
// @Success 200 {object} handlers.CleanExpiredResponse "Expired non-approved requests cleaned"
// @Failure 401 {object} models.SimpleMessageResponse "Unauthorized: admin only"
// @Failure 500 {object} models.SimpleMessageResponse "Failed to clean expired requests"
// @Router /admin/clean-expired [post]
func CleanExpiredRequests(c *gin.Context) <span class="cov8" title="1">{
        // Check if the user is logged in and get logger
        sessionData := GetSessionData(c)
        reqLogger := RequestLogger(c)

        isAdmin, _ := sessionData["isAdmin"].(bool)
        if !isAdmin </span><span class="cov8" title="1">{
                reqLogger.Warn("Unauthorized access attempt to CleanExpiredRequests")
                c.JSON(http.StatusUnauthorized, models.SimpleMessageResponse{Error: "Unauthorized: admin only"})
                return
        }</span>

        <span class="cov8" title="1">now := time.Now()
        result := db.DB.
                Where("end_date &lt; ? AND status = ?", now, "Requested").
                Delete(&amp;models.RequestData{})

        if result.Error != nil </span><span class="cov8" title="1">{
                reqLogger.Error("Failed to clean expired non-approved requests", zap.Error(result.Error))
                c.JSON(http.StatusInternalServerError, models.SimpleMessageResponse{Error: "Failed to clean expired requests"})
                return
        }</span>

        <span class="cov8" title="1">reqLogger.Info("Expired non-approved requests cleaned",
                zap.Int64("deleted", result.RowsAffected),
        )
        c.JSON(http.StatusOK, CleanExpiredResponse{
                Message: "Expired non-approved requests cleaned",
                Deleted: result.RowsAffected,
        })</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package handlers

import (
        "fmt"
        "kube-jit/internal/models"
        "kube-jit/pkg/k8s"
        "kube-jit/pkg/sessioncookie"
        "net/http"
        "strings"

        "github.com/gin-contrib/sessions"
        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
)

// GetSessionData retrieves session data from the context or panics
func GetSessionData(c *gin.Context) map[string]interface{} <span class="cov8" title="1">{
        sessionData := c.MustGet("sessionData").(map[string]interface{})

        return sessionData
}</span>

// Logout godoc
// @Summary Log out and clear all session cookies
// @Description Clears all session cookies with the session prefix and logs the user out.
// @Tags auth
// @Accept  json
// @Produce  json
// @Success 200 {object} models.SimpleMessageResponse "Logged out successfully"
// @Router /logout [post]
func Logout(c *gin.Context) <span class="cov8" title="1">{
        // Iterate through cookies with the session prefix
        for i := 0; ; i++ </span><span class="cov8" title="1">{
                cookieName := fmt.Sprintf("%s%d", sessioncookie.SessionPrefix, i)
                _, err := c.Cookie(cookieName)
                if err != nil </span><span class="cov8" title="1">{
                        break</span> // Stop when no more cookies are found
                }

                // Clear the cookie by setting its MaxAge to -1
                <span class="cov8" title="1">c.SetCookie(cookieName, "", -1, "/", "", true, true)</span>
        }

        // Respond with a success message
        <span class="cov8" title="1">c.JSON(http.StatusOK, models.SimpleMessageResponse{Message: "Logged out successfully"})</span>
}

// CommonPermissionsResponse represents the response for CommonPermissions
type CommonPermissionsResponse struct {
        IsApprover             bool          `json:"isApprover"`
        ApproverGroups         []models.Team `json:"approverGroups"`
        IsAdmin                bool          `json:"isAdmin"`
        IsPlatformApprover     bool          `json:"isPlatformApprover"`
        AdminGroups            []models.Team `json:"adminGroups"`
        PlatformApproverGroups []models.Team `json:"platformApproverGroups"`
}

// CommonPermissionsRequest represents the request payload for CommonPermissions
type CommonPermissionsRequest struct {
        Provider string `json:"provider" example:"github"`
}

// CommonPermissions godoc
// @Summary Get common permissions for the logged in user
// @Description Returns the user's permissions and group memberships for the specified provider (GitHub, Google, Azure).
// @Description Requires one or more cookies named kube_jit_session_&lt;number&gt; (e.g., kube_jit_session_0, kube_jit_session_1).
// @Description Pass split cookies in the Cookie header, for example:
// @Description     -H "Cookie: kube_jit_session_0=${cookie_0};kube_jit_session_1=${cookie_1}"
// @Description Note: Swagger UI cannot send custom Cookie headers due to browser security restrictions. Use curl for testing with split cookies.
// @Tags auth
// @Accept  json
// @Produce  json
// @Param   Cookie header string true "Session cookies (multiple allowed, names: kube_jit_session_0, kube_jit_session_1, etc.)"
// @Param   request body handlers.CommonPermissionsRequest true "Provider payload"
// @Success 200 {object} handlers.CommonPermissionsResponse "User permissions and groups"
// @Failure 400 {object} models.SimpleMessageResponse "Missing or invalid provider"
// @Failure 401 {object} models.SimpleMessageResponse "Unauthorized: no token in session data"
// @Failure 500 {object} models.SimpleMessageResponse "Failed to fetch user groups"
// @Router /permissions [post]
// CommonPermissions checks if the user has common permissions
func CommonPermissions(c *gin.Context) <span class="cov8" title="1">{
        // Check if the user is logged in and get logger
        sessionData := GetSessionData(c)
        reqLogger := RequestLogger(c)

        // Parse provider from payload
        var payload struct {
                Provider string `json:"provider"`
        }
        if err := c.ShouldBindJSON(&amp;payload); err != nil || payload.Provider == "" </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, models.SimpleMessageResponse{Error: "Missing or invalid provider"})
                return
        }</span>

        // Check if cached in session
        <span class="cov8" title="1">isApprover, isApproverOk := sessionData["isApprover"].(bool)
        isAdmin, isAdminOk := sessionData["isAdmin"].(bool)
        isPlatformApprover, isPlatformApproverOk := sessionData["isPlatformApprover"].(bool)
        approverGroups, approverGroupsOk := sessionData["approverGroups"]
        adminGroups, adminGroupsOk := sessionData["adminGroups"]
        platformApproverGroups, platformApproverGroupsOk := sessionData["platformApproverGroups"]
        if isApproverOk &amp;&amp; isAdminOk &amp;&amp; isPlatformApproverOk &amp;&amp; approverGroupsOk &amp;&amp; adminGroupsOk &amp;&amp; platformApproverGroupsOk </span><span class="cov8" title="1">{
                c.JSON(http.StatusOK, gin.H{
                        "isApprover":             isApprover,
                        "approverGroups":         approverGroups,
                        "isAdmin":                isAdmin,
                        "isPlatformApprover":     isPlatformApprover,
                        "adminGroups":            adminGroups,
                        "platformApproverGroups": platformApproverGroups,
                })
                return
        }</span>

        // Get token from session
        <span class="cov8" title="1">token, _ := sessionData["token"].(string)

        var userGroups []models.Team
        var err error

        // Fetch user groups based on the provider
        switch payload.Provider </span>{
        case "github":<span class="cov8" title="1"> // GitHub provider
                userGroups, err = GetGithubTeams(token, reqLogger)
                if err != nil </span><span class="cov8" title="1">{
                        c.JSON(http.StatusInternalServerError, models.SimpleMessageResponse{Error: "Failed to fetch GitHub teams"})
                        return
                }</span>
        case "google":<span class="cov8" title="1"> // Google provider
                userEmail, _ := sessionData["email"].(string)
                userGroups, err = GetGoogleGroupsWithWorkloadIdentity(userEmail, reqLogger)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, models.SimpleMessageResponse{Error: "Failed to fetch Google groups"})
                        return
                }</span>
        case "azure":<span class="cov8" title="1"> // Azure provider
                userGroups, err = GetAzureGroups(token, reqLogger)
                if err != nil </span><span class="cov8" title="1">{
                        c.JSON(http.StatusInternalServerError, models.SimpleMessageResponse{Error: "Failed to fetch Azure groups"})
                        return
                }</span>
        default:<span class="cov8" title="1">
                c.JSON(http.StatusBadRequest, models.SimpleMessageResponse{Error: "Unknown provider"})
                return</span>
        }

        // Match user groups to approver/admin teams
        <span class="cov8" title="1">isAdmin, isPlatformApprover, matchedPlatformGroups, matchedAdminGroups := MatchUserGroups(
                userGroups,
                k8s.PlatformApproverTeams,
                k8s.AdminTeams,
        )

        // Check and append if user is in any JitGroup for any cluster
        var matchedApproverGroups []models.Team
        for _, clusterName := range k8s.ClusterNames </span><span class="cov8" title="1">{
                jitGroups, err := k8s.GetJitGroups(clusterName)
                if err != nil </span><span class="cov8" title="1">{
                        reqLogger.Error("Error fetching JitGroups for cluster", zap.String("clusterName", clusterName), zap.Error(err))
                        continue</span>
                }
                <span class="cov8" title="1">groups, _, _ := unstructured.NestedSlice(jitGroups.Object, "spec", "groups")
                for _, group := range groups </span><span class="cov8" title="1">{
                        groupMap, ok := group.(map[string]any)
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">groupID, ok := groupMap["groupID"].(string)
                        groupName, _ := groupMap["groupName"].(string)
                        if ok </span><span class="cov8" title="1">{
                                for _, userGroup := range userGroups </span><span class="cov8" title="1">{
                                        if userGroup.ID == groupID </span><span class="cov8" title="1">{
                                                matchedApproverGroups = append(matchedApproverGroups, models.Team{ID: groupID, Name: groupName})
                                        }</span>
                                }
                        }
                }
        }

        // Check if the user is an approver
        <span class="cov8" title="1">isApprover = len(matchedApproverGroups) &gt; 0

        // Update session
        sessionData["isApprover"] = isApprover
        sessionData["approverGroups"] = matchedApproverGroups
        sessionData["isAdmin"] = isAdmin
        sessionData["isPlatformApprover"] = isPlatformApprover
        sessionData["adminGroups"] = matchedAdminGroups
        sessionData["platformApproverGroups"] = matchedPlatformGroups

        session := sessions.Default(c)
        session.Set("data", sessionData)
        sessioncookie.SplitSessionData(c)

        c.JSON(http.StatusOK, CommonPermissionsResponse{
                IsApprover:             isApprover,
                ApproverGroups:         matchedApproverGroups,
                IsAdmin:                isAdmin,
                IsPlatformApprover:     isPlatformApprover,
                AdminGroups:            matchedAdminGroups,
                PlatformApproverGroups: matchedPlatformGroups,
        })</span>
}

// isAllowedUser checks if the user is allowed to access the api
// It checks the provider and email domain for Google and Azure
// and checks the organization membership for GitHub
// It returns true if the user is allowed, false otherwise
var isAllowedUser = func(provider, email string, extraInfo map[string]any) bool <span class="cov8" title="1">{
        switch provider </span>{
        case "google", "azure":<span class="cov8" title="1">
                return strings.HasSuffix(email, "@"+allowedDomain)</span>
        case "github":<span class="cov8" title="1">
                orgs, ok := extraInfo["orgs"].([]string)
                if !ok </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">for _, org := range orgs </span><span class="cov8" title="1">{
                        if org == allowedOrg </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
                <span class="cov8" title="1">return false</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package handlers

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "kube-jit/internal/models"
        "kube-jit/pkg/sessioncookie"
        "kube-jit/pkg/utils"
        "net/http"
        "time"

        "github.com/gin-contrib/sessions"
        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
        "golang.org/x/oauth2"
)

// getAzureOAuthConfig constructs and returns the Azure OAuth2 config.
// This ensures it uses the current values of clientID, clientSecret, etc.
var getAzureOAuthConfig = func() *oauth2.Config <span class="cov8" title="1">{
        return &amp;oauth2.Config{
                ClientID:     clientID,     // Reads current package-level clientID from common.go
                ClientSecret: clientSecret, // Reads current package-level clientSecret from common.go
                RedirectURL:  redirectUri,  // Reads current package-level redirectUri from common.go
                Scopes:       []string{"openid", "email", "profile", "User.Read", "Directory.Read.All"},
                Endpoint: oauth2.Endpoint{
                        AuthURL:  utils.MustGetEnv("AZURE_AUTH_URL"),
                        TokenURL: utils.MustGetEnv("AZURE_TOKEN_URL"),
                },
        }
}</span>

// Helper to fetch and decode Azure user profile
var fetchAzureUserProfile = func(token string) (*models.AzureUser, error) <span class="cov0" title="0">{
        client := oauth2.NewClient(context.Background(), oauth2.StaticTokenSource(&amp;oauth2.Token{AccessToken: token}))
        resp, err := client.Get("https://graph.microsoft.com/v1.0/me")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch Azure user info: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("error fetching user profile from Azure AD: %s", string(body))
        }</span>

        <span class="cov0" title="0">var azureUser models.AzureUser
        if err := json.NewDecoder(resp.Body).Decode(&amp;azureUser); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode Azure user info: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;azureUser, nil</span>
}

// HandleAzureLogin godoc
// @Summary Azure OAuth callback
// @Description Handles the Azure OAuth callback, exchanges the code for an access token, fetches user info, sets session data, and returns normalized user data and expiration time.
// @Tags azure
// @Accept  json
// @Produce  json
// @Param   code query string true "Azure OAuth authorization code"
// @Success 200 {object} models.LoginResponse "Normalized user data and expiration time"
// @Failure 400 {object} models.SimpleMessageResponse "Missing or invalid code"
// @Failure 403 {object} models.SimpleMessageResponse "Unauthorized domain"
// @Failure 500 {object} models.SimpleMessageResponse "Internal server error"
// @Router /oauth/azure/callback [get]
func HandleAzureLogin(c *gin.Context) <span class="cov8" title="1">{
        code := c.Query("code")
        if code == "" </span><span class="cov8" title="1">{
                logger.Warn("Missing 'code' query parameter in Azure login")
                c.JSON(http.StatusBadRequest, models.SimpleMessageResponse{Error: "Code query parameter is required"})
                return
        }</span>

        <span class="cov8" title="1">currentAzureOAuthConfig := getAzureOAuthConfig() // Use the function here

        // Exchange the authorization code for a token
        token, err := currentAzureOAuthConfig.Exchange(context.Background(), code)
        if err != nil </span><span class="cov8" title="1">{
                // Log the detailed error from the Exchange call
                logger.Error("Failed to exchange Azure token",
                        zap.Error(err), // This will print the underlying error from the oauth2 library
                        zap.String("codeUsed", code),
                        zap.String("clientIDUsed", currentAzureOAuthConfig.ClientID),
                        zap.String("clientSecretUsed", currentAzureOAuthConfig.ClientSecret), // Be careful logging secrets, even in tests
                        zap.String("redirectURIUsed", currentAzureOAuthConfig.RedirectURL),
                        zap.String("tokenURLUsed", currentAzureOAuthConfig.Endpoint.TokenURL),
                )
                c.JSON(http.StatusInternalServerError, models.SimpleMessageResponse{Error: "Failed to exchange token"})
                return
        }</span>

        // Fetch user info using the helper
        <span class="cov8" title="1">azureUser, err := fetchAzureUserProfile(token.AccessToken)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("Failed to fetch Azure user info", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.SimpleMessageResponse{Error: err.Error()})
                return
        }</span>

        // Use Mail if present, otherwise fallback to UserPrincipalName
        <span class="cov8" title="1">email := azureUser.Mail
        if email == "" </span><span class="cov0" title="0">{
                email = azureUser.UserPrincipalName
        }</span>

        // Check if the user is allowed to log in
        <span class="cov8" title="1">if !isAllowedUser("azure", email, nil) </span><span class="cov8" title="1">{
                logger.Warn("Login attempt from unauthorized Azure domain", zap.String("email", email))
                c.JSON(http.StatusForbidden, models.SimpleMessageResponse{Error: "Unauthorized domain"})
                return
        }</span>

        // Normalize the user data
        <span class="cov8" title="1">normalizedUserData := models.NormalizedUserData{
                ID:        azureUser.ID,
                Name:      azureUser.DisplayName,
                Email:     email,
                AvatarURL: "", // Azure AD doesn't provide an avatar URL by default
                Provider:  "azure",
        }

        // Prepare session data
        sessionData := map[string]interface{}{
                "email": email,
                "token": token.AccessToken,
                "id":    azureUser.ID,
                "name":  azureUser.DisplayName,
        }

        // Save the session data in the session
        session := sessions.Default(c)
        session.Set("data", sessionData)

        // Split the session data into cookies
        sessioncookie.SplitSessionData(c)

        logger.Debug("Session cookies set successfully for Azure login", zap.String("name", azureUser.DisplayName))

        // Respond with the normalized user data
        c.JSON(http.StatusOK, models.LoginResponse{
                UserData:  normalizedUserData,
                ExpiresIn: int(time.Until(token.Expiry).Seconds()),
        })</span>
}

// GetAzureProfile godoc
// @Summary Get the logged in user's Azure profile
// @Description Returns the normalized Azure user profile for the authenticated user.
// @Description Requires one or more cookies named kube_jit_session_&lt;number&gt; (e.g., kube_jit_session_0, kube_jit_session_1).
// @Description Pass split cookies in the Cookie header, for example:
// @Description     -H "Cookie: kube_jit_session_0=${cookie_0};kube_jit_session_1=${cookie_1}"
// @Description Note: Swagger UI cannot send custom Cookie headers due to browser security restrictions. Use curl for testing with split cookies.
// @Tags azure
// @Accept  json
// @Produce  json
// @Param   Cookie header string true "Session cookies (multiple allowed, names: kube_jit_session_0, kube_jit_session_1, etc.)"
// @Success 200 {object} models.NormalizedUserData
// @Failure 401 {object} models.SimpleMessageResponse "Unauthorized: no token in session data"
// @Failure 500 {object} models.SimpleMessageResponse "Internal server error"
// @Router /azure/profile [get]
func GetAzureProfile(c *gin.Context) <span class="cov8" title="1">{
        // Check if the user is logged in
        sessionData := GetSessionData(c)
        reqLogger := RequestLogger(c)

        reqLogger.Debug("User authenticated", zap.String("userID", sessionData["id"].(string)))

        token, ok := sessionData["token"].(string)
        if !ok || token == "" </span><span class="cov8" title="1">{
                reqLogger.Warn("No token in session data for Azure profile")
                c.JSON(http.StatusUnauthorized, models.SimpleMessageResponse{Error: "Unauthorized: no token in session data"})
                return
        }</span>

        // Fetch user info using the helper
        <span class="cov8" title="1">azureUser, err := fetchAzureUserProfile(token)
        if err != nil </span><span class="cov8" title="1">{
                reqLogger.Error("Failed to fetch Azure user profile", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.SimpleMessageResponse{Error: err.Error()})
                return
        }</span>

        // Normalize the response to match the structure of other providers
        <span class="cov8" title="1">normalizedUserData := map[string]any{
                "id":         azureUser.ID,
                "name":       azureUser.DisplayName,
                "email":      azureUser.Mail,
                "avatar_url": "",
                "provider":   "azure",
        }

        c.JSON(http.StatusOK, normalizedUserData)</span>
}

// Fetch Azure AD groups for a user using their OAuth token
var GetAzureGroups = func(token string, reqLogger *zap.Logger) ([]models.Team, error) <span class="cov0" title="0">{
        client := oauth2.NewClient(context.Background(), oauth2.StaticTokenSource(&amp;oauth2.Token{AccessToken: token}))
        resp, err := client.Get("https://graph.microsoft.com/v1.0/me/memberOf")
        if err != nil </span><span class="cov0" title="0">{
                reqLogger.Error("Failed to fetch Azure groups", zap.Error(err))
                return nil, fmt.Errorf("failed to fetch groups from Azure AD")
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                reqLogger.Warn("Error fetching Azure groups", zap.String("response", string(body)))
                return nil, fmt.Errorf("error fetching groups from Azure AD")
        }</span>

        <span class="cov0" title="0">var groupsResponse struct {
                Value []struct {
                        ID          string `json:"id"`
                        DisplayName string `json:"displayName"`
                } `json:"value"`
        }
        if err := json.NewDecoder(resp.Body).Decode(&amp;groupsResponse); err != nil </span><span class="cov0" title="0">{
                reqLogger.Error("Failed to decode Azure groups response", zap.Error(err))
                return nil, fmt.Errorf("failed to decode groups response")
        }</span>

        <span class="cov0" title="0">var teams []models.Team
        for _, g := range groupsResponse.Value </span><span class="cov0" title="0">{
                teams = append(teams, models.Team{
                        ID:   g.ID,
                        Name: g.DisplayName,
                })
        }</span>
        <span class="cov0" title="0">return teams, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package handlers

import (
        "fmt"
        "kube-jit/internal/db"
        "kube-jit/internal/models"
        "kube-jit/pkg/email"
        "kube-jit/pkg/k8s"
        "kube-jit/pkg/utils"
        "net/http"
        "os"
        "time"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

var (
        // Get OAuth values environment variables
        oauthProvider = utils.MustGetEnv("OAUTH_PROVIDER")
        clientID      = utils.MustGetEnv("OAUTH_CLIENT_ID")
        clientSecret  = utils.MustGetEnv("OAUTH_CLIENT_SECRET")
        redirectUri   = utils.MustGetEnv("OAUTH_REDIRECT_URI")
        allowedDomain string
        allowedOrg    string
        httpClient    = &amp;http.Client{
                Timeout: 60 * time.Second,
        }
)

// OauthClientIdResponse represents the response for GetOauthClientId
type OauthClientIdResponse struct {
        ClientID    string `json:"client_id"`
        Provider    string `json:"provider"`
        RedirectURI string `json:"redirect_uri"`
        AuthURL     string `json:"auth_url"`
}

// BuildShaResponse represents the response for GetBuildSha
type BuildShaResponse struct {
        Sha string `json:"sha"`
}

func init() <span class="cov8" title="1">{
        // Set the admin email for Google OAuth provider
        if oauthProvider == "google" </span><span class="cov0" title="0">{
                allowedDomain = utils.MustGetEnv("ALLOWED_DOMAIN")
        }</span> else<span class="cov8" title="1"> if oauthProvider == "github" </span><span class="cov0" title="0">{
                allowedOrg = utils.MustGetEnv("ALLOWED_GITHUB_ORG")
        }</span> else<span class="cov8" title="1"> if oauthProvider == "azure" </span><span class="cov8" title="1">{
                allowedDomain = utils.MustGetEnv("ALLOWED_DOMAIN")
        }</span>
}

// ClustersAndRolesResponse represents the response for clusters and roles
type ClustersAndRolesResponse struct {
        Clusters []string       `json:"clusters"`
        Roles    []models.Roles `json:"roles"`
}

// K8sCallback godoc
// @Summary Kubernetes controller callback for status update
// @Description Used by the downstream Kubernetes controller to callback for status update. Validates the signed URL and updates the request status in the database. Returns a success message.
// @Tags k8s
// @Accept  json
// @Produce  json
// @Param   request body object true "Callback payload (ticketID, status, message)"
// @Success 200 {object} models.SimpleMessageResponse "Status updated successfully"
// @Failure 400 {object} models.SimpleMessageResponse "Invalid request"
// @Failure 401 {object} models.SimpleMessageResponse "Unauthorized"
// @Failure 500 {object} models.SimpleMessageResponse "Failed to update request"
// @Router /k8s-callback [post]
func K8sCallback(c *gin.Context) <span class="cov0" title="0">{
        var callbackData struct {
                TicketID string `json:"ticketID"`
                Status   string `json:"status"`
                Message  string `json:"message"`
        }

        if err := c.ShouldBindJSON(&amp;callbackData); err != nil </span><span class="cov0" title="0">{
                logger.Warn("Failed to bind JSON in K8sCallback", zap.Error(err))
                c.JSON(http.StatusBadRequest, models.SimpleMessageResponse{Error: "Invalid request"})
                return
        }</span>

        <span class="cov0" title="0">callbackURL := c.Request.URL
        if !utils.ValidateSignedURL(callbackURL, k8s.CallbackHostOverride) </span><span class="cov0" title="0">{
                logger.Warn("Invalid or expired signed URL in K8sCallback")
                c.JSON(http.StatusUnauthorized, models.SimpleMessageResponse{Error: "Unauthorized"})
                return
        }</span>

        <span class="cov0" title="0">if err := db.DB.Model(&amp;models.RequestData{}).Where("id = ?", callbackData.TicketID).Updates(map[string]interface{}{
                "status": callbackData.Status,
                "notes":  callbackData.Message,
        }).Error; err != nil </span><span class="cov0" title="0">{
                logger.Error("Error updating request in K8sCallback",
                        zap.String("ticketID", callbackData.TicketID),
                        zap.Error(err),
                )
                c.JSON(http.StatusInternalServerError, models.SimpleMessageResponse{Error: "Failed to update request (database error)"})
                return
        }</span>

        <span class="cov0" title="0">logger.Info("Received callback for ticket",
                zap.String("ticketID", callbackData.TicketID),
                zap.String("status", callbackData.Status),
        )

        // Send status change email to user
        var req models.RequestData
        if err := db.DB.Where("id = ?", callbackData.TicketID).First(&amp;req).Error; err == nil &amp;&amp; req.Email != "" </span><span class="cov0" title="0">{
                body := email.BuildRequestEmail(email.EmailRequestDetails{
                        Username:      req.Username,
                        ClusterName:   req.ClusterName,
                        Namespaces:    req.Namespaces,
                        RoleName:      req.RoleName,
                        Justification: req.Justification,
                        StartDate:     req.StartDate,
                        EndDate:       req.EndDate,
                        Status:        callbackData.Status,
                        Message:       callbackData.Message,
                })
                go func() </span><span class="cov0" title="0">{
                        if err := email.SendMail(req.Email, fmt.Sprintf("Your JIT request #%s is now %s", callbackData.TicketID, callbackData.Status), body); err != nil </span><span class="cov0" title="0">{
                                logger.Warn("Failed to send status change email (K8sCallback)", zap.String("email", req.Email), zap.Error(err))
                        }</span>
                }()
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, models.SimpleMessageResponse{Message: "Success"})</span>
}

// GetOauthClientId godoc
// @Summary Get OAuth client configuration
// @Description Returns the OAuth client_id, provider, redirect URI, and auth URL for the frontend to initiate login.
// @Tags auth
// @Accept  json
// @Produce  json
// @Success 200 {object} handlers.OauthClientIdResponse "OAuth client configuration"
// @Router /client_id [get]
func GetOauthClientId(c *gin.Context) <span class="cov8" title="1">{
        authURL := ""
        // For Azure, specifically:
        if oauthProvider == "azure" </span><span class="cov8" title="1">{
                authURL = getAzureOAuthConfig().Endpoint.AuthURL
        }</span>

        <span class="cov8" title="1">response := OauthClientIdResponse{
                ClientID:    clientID,
                Provider:    oauthProvider,
                RedirectURI: redirectUri,
                AuthURL:     authURL,
        }

        c.JSON(http.StatusOK, response)</span>
}

// GetClustersAndRoles godoc
// @Summary Get available clusters and roles
// @Description Returns the list of clusters and roles available to the user.
// @Description Requires one or more cookies named kube_jit_session_&lt;number&gt; (e.g., kube_jit_session_0, kube_jit_session_1).
// @Description Pass split cookies in the Cookie header, for example:
// @Description     -H "Cookie: kube_jit_session_0=${cookie_0};kube_jit_session_1=${cookie_1}"
// @Description Note: Swagger UI cannot send custom Cookie headers due to browser security restrictions. Use curl for testing with split cookies.
// @Tags records
// @Accept  json
// @Produce  json
// @Param   Cookie header string true "Session cookies (multiple allowed, names: kube_jit_session_0, kube_jit_session_1, etc.)"
// @Success 200 {object} ClustersAndRolesResponse "clusters and roles"
// @Failure 401 {object} models.SimpleMessageResponse "Unauthorized: no token in session data"
// @Router /roles-and-clusters [get]
func GetClustersAndRoles(c *gin.Context) <span class="cov8" title="1">{
        response := ClustersAndRolesResponse{
                Clusters: k8s.ClusterNames,
                Roles:    k8s.AllowedRoles,
        }
        c.JSON(http.StatusOK, response)
}</span>

// GetBuildSha godoc
// @Summary Get build SHA
// @Description Returns the current build SHA for the running API.
// @Tags health
// @Accept  json
// @Produce  json
// @Success 200 {object} handlers.BuildShaResponse "Current build SHA"
// @Router /build-sha [get]
func GetBuildSha(c *gin.Context) <span class="cov8" title="1">{
        c.JSON(http.StatusOK, BuildShaResponse{Sha: os.Getenv("BUILD_SHA")})
}</span>

// GetApprovingGroups godoc
// @Summary Get platform approving groups
// @Description Returns the list of platform approving groups for the authenticated user.
// @Description Requires one or more cookies named kube_jit_session_&lt;number&gt; (e.g., kube_jit_session_0, kube_jit_session_1).
// @Description Pass split cookies in the Cookie header, for example:
// @Description     -H "Cookie: kube_jit_session_0=${cookie_0};kube_jit_session_1=${cookie_1}"
// @Description Note: Swagger UI cannot send custom Cookie headers due to browser security restrictions. Use curl for testing with split cookies.
// @Tags records
// @Accept  json
// @Produce  json
// @Param   Cookie header string true "Session cookies (multiple allowed, names: kube_jit_session_0, kube_jit_session_1, etc.)"
// @Success 200 {array} models.Team
// @Failure 401 {object} models.SimpleMessageResponse "Unauthorized: no token in session data"
// @Router /approving-groups [get]
func GetApprovingGroups(c *gin.Context) <span class="cov8" title="1">{
        // Check if the user is logged in
        sessionData := GetSessionData(c)

        // Retrieve the token from the session data
        token, ok := sessionData["token"].(string)
        if !ok || token == "" </span><span class="cov8" title="1">{
                c.JSON(http.StatusUnauthorized, models.SimpleMessageResponse{Error: "Unauthorized: no token in session data"})
                return
        }</span>

        // Return the platform approving groups
        <span class="cov8" title="1">c.JSON(http.StatusOK, k8s.PlatformApproverTeams)</span>
}

// HealthCheck godoc
// @Summary Health check endpoint
// @Description Returns a simple status message to verify the API is running.
// @Tags health
// @Accept  json
// @Produce  json
// @Success 200 {object} models.SimpleMessageResponse "API is healthy"
// @Router /healthz [get]
func HealthCheck(c *gin.Context) <span class="cov8" title="1">{
        c.JSON(http.StatusOK, models.SimpleMessageResponse{Status: "healthy"})
}</span>

// contains checks if a string is present in a slice of strings
func contains(slice []string, item string) bool <span class="cov8" title="1">{
        for _, a := range slice </span><span class="cov8" title="1">{
                if a == item </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// MatchUserGroups checks if the user belongs to any approver or admin groups
// It returns boolean flags indicating if the user is an approver or admin
// along with the matched approver and admin groups
func MatchUserGroups(
        userGroups []models.Team,
        platformTeams []models.Team,
        adminTeams []models.Team,
) (isAdmin bool, isPlatformApprover bool, matchedPlatformGroups, matchedAdminGroups []models.Team) <span class="cov8" title="1">{
        for _, group := range userGroups </span><span class="cov8" title="1">{
                for _, approverGroup := range platformTeams </span><span class="cov8" title="1">{
                        if group.ID == approverGroup.ID &amp;&amp; group.Name == approverGroup.Name </span><span class="cov8" title="1">{
                                matchedPlatformGroups = append(matchedPlatformGroups, group)
                        }</span>
                }
                <span class="cov8" title="1">for _, adminGroup := range adminTeams </span><span class="cov8" title="1">{
                        if group.ID == adminGroup.ID &amp;&amp; group.Name == adminGroup.Name </span><span class="cov8" title="1">{
                                matchedAdminGroups = append(matchedAdminGroups, group)
                        }</span>
                }
        }
        <span class="cov8" title="1">isAdmin = len(matchedAdminGroups) &gt; 0
        isPlatformApprover = len(matchedPlatformGroups) &gt; 0
        return</span>
}

func RequestLogger(c *gin.Context) *zap.Logger <span class="cov8" title="1">{
        sessionData := GetSessionData(c)
        userID, _ := sessionData["id"].(string)
        username, _ := sessionData["name"].(string)
        return logger.With(
                zap.String("userID", userID),
                zap.String("username", username),
        )
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package handlers

import (
        "fmt"
        "kube-jit/internal/db"
        "kube-jit/internal/models"
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// GetRecords godoc
// @Summary Get JIT requests for a user
// @Description Returns the latest JIT requests for a user with optional limit and date range.
// @Description Requires one or more cookies named kube_jit_session_&lt;number&gt; (e.g., kube_jit_session_0, kube_jit_session_1).
// @Description Pass split cookies in the Cookie header, for example:
// @Description     -H "Cookie: kube_jit_session_0=${cookie_0};kube_jit_session_1=${cookie_1}"
// @Description Note: Swagger UI cannot send custom Cookie headers due to browser security restrictions. Use curl for testing with split cookies:
// @Description Login required to test via browser, else test via curl
// @Tags records
// @Accept  json
// @Produce  json
// @Param   Cookie header string true "Session cookies (multiple allowed, names: kube_jit_session_0, kube_jit_session_1, etc.)"
// @Param   userID     query    string  false  "User ID"
// @Param   username   query    string  false  "Username"
// @Param   limit      query    int     false  "Limit"
// @Success 200 {array} models.RequestWithNamespaceApprovers
// @Failure 500 {object} models.SimpleMessageResponse
// @Router /history [get]
func GetRecords(c *gin.Context) <span class="cov8" title="1">{
        // Check if the user is logged in and get logger
        sessionData := GetSessionData(c)
        reqLogger := RequestLogger(c)

        isAdmin, _ := sessionData["isAdmin"].(bool)
        isPlatformApprover, _ := sessionData["isPlatformApprover"].(bool)
        userID := c.Query("userID")
        username := c.Query("username")
        limit := c.Query("limit")
        startDate := c.Query("startDate")
        endDate := c.Query("endDate")

        limitInt, err := strconv.Atoi(limit)
        if err != nil || limitInt &lt;= 0 </span><span class="cov8" title="1">{
                limitInt = 1
        }</span>

        <span class="cov8" title="1">var requests []models.RequestData
        query := db.DB.Order("created_at desc").Limit(limitInt)
        if isAdmin || isPlatformApprover </span><span class="cov8" title="1">{
                if userID != "" </span><span class="cov8" title="1">{
                        query = query.Where("user_id = ?", userID)
                }</span>
                <span class="cov8" title="1">if username != "" </span><span class="cov0" title="0">{
                        query = query.Where("username = ?", username)
                }</span>
        } else<span class="cov8" title="1"> {
                if userID != "" </span><span class="cov8" title="1">{
                        query = query.Where("user_id = ? OR approver_ids @&gt; ?", userID, fmt.Sprintf(`["%s"]`, userID))
                }</span> else<span class="cov8" title="1"> if username != "" </span><span class="cov0" title="0">{
                        query = query.Where("username = ? OR approver_names @&gt; ?", username, fmt.Sprintf(`["%s"]`, username))
                }</span>
        }
        <span class="cov8" title="1">if startDate != "" &amp;&amp; endDate != "" </span><span class="cov0" title="0">{
                query = query.Where("created_at BETWEEN ? AND ?", startDate, endDate)
        }</span>
        <span class="cov8" title="1">if err := query.Find(&amp;requests).Error; err != nil </span><span class="cov8" title="1">{
                reqLogger.Error("Error fetching records in GetRecords", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.SimpleMessageResponse{Error: "Failed to fetch records"})
                return
        }</span>

        <span class="cov8" title="1">var requestsWithApprovals []models.RequestWithNamespaceApprovers

        for _, req := range requests </span><span class="cov8" title="1">{
                var nsApprovals []models.NamespaceApprovalInfo
                if err := db.DB.Table("request_namespaces").
                        Select("namespace, group_name, group_id, approved, approver_id, approver_name").
                        Where("request_id = ?", req.ID).
                        Find(&amp;nsApprovals).Error; err != nil </span><span class="cov8" title="1">{
                        reqLogger.Error("Error fetching namespace approvals for request", zap.Uint("requestID", req.ID), zap.Error(err))
                        c.JSON(http.StatusInternalServerError, models.SimpleMessageResponse{Error: "Failed to fetch namespace approvals"})
                        return
                }</span>
                <span class="cov8" title="1">if nsApprovals == nil </span><span class="cov0" title="0">{
                        nsApprovals = []models.NamespaceApprovalInfo{} // Ensure empty slice instead of nil
                }</span>
                <span class="cov8" title="1">requestsWithApprovals = append(requestsWithApprovals, models.RequestWithNamespaceApprovers{
                        RequestData:        req,
                        NamespaceApprovals: nsApprovals,
                })</span>
        }

        <span class="cov8" title="1">if requestsWithApprovals == nil </span><span class="cov8" title="1">{
                requestsWithApprovals = []models.RequestWithNamespaceApprovers{}
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, requestsWithApprovals)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package handlers

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "kube-jit/internal/models"
        "kube-jit/pkg/sessioncookie"
        "net/http"
        "net/url"
        "strconv"
        "strings"

        "github.com/gin-contrib/sessions"
        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// Helper to fetch and decode GitHub user profile
func fetchGitHubUserProfile(token string) (*models.GitHubUser, error) <span class="cov8" title="1">{
        req, err := http.NewRequest("GET", "https://api.github.com/user", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request for GitHub user: %w", err)
        }</span>
        <span class="cov8" title="1">req.Header.Set("Authorization", "Bearer "+token)

        resp, err := httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch GitHub user: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("error fetching user data from GitHub: %s", string(body))
        }</span>

        <span class="cov8" title="1">var githubUser models.GitHubUser
        if err := json.NewDecoder(resp.Body).Decode(&amp;githubUser); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode GitHub user: %w", err)
        }</span>
        <span class="cov8" title="1">return &amp;githubUser, nil</span>
}

// Helper to fetch primary/verified email if not present in user profile
func fetchGitHubPrimaryEmail(token string) (string, error) <span class="cov0" title="0">{
        req, err := http.NewRequest("GET", "https://api.github.com/user/emails", nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create request for GitHub emails: %w", err)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+token)

        resp, err := httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to fetch GitHub emails: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return "", fmt.Errorf("error fetching emails from GitHub: %s", string(body))
        }</span>

        <span class="cov0" title="0">var emails []struct {
                Email    string `json:"email"`
                Primary  bool   `json:"primary"`
                Verified bool   `json:"verified"`
        }
        if err := json.NewDecoder(resp.Body).Decode(&amp;emails); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to decode GitHub emails: %w", err)
        }</span>
        <span class="cov0" title="0">for _, e := range emails </span><span class="cov0" title="0">{
                if e.Primary &amp;&amp; e.Verified </span><span class="cov0" title="0">{
                        return e.Email, nil
                }</span>
        }
        <span class="cov0" title="0">for _, e := range emails </span><span class="cov0" title="0">{
                if e.Verified </span><span class="cov0" title="0">{
                        return e.Email, nil
                }</span>
        }
        <span class="cov0" title="0">return "", fmt.Errorf("no verified email found")</span>
}

// Fetch GitHub teams for a user using their OAuth token
// This function is used to get the teams associated with the authenticated user
// It sends a GET request to the GitHub API endpoint for user teams
// and returns a slice of models.Team
// Each team is represented by its ID and name
// It returns an error if the request fails or if the response is not as expected
var GetGithubTeams = func(token string, reqLogger *zap.Logger) ([]models.Team, error) <span class="cov0" title="0">{
        req, err := http.NewRequest("GET", "https://api.github.com/user/teams", nil)
        if err != nil </span><span class="cov0" title="0">{
                reqLogger.Error("Failed to create request for GitHub teams", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+token)

        resp, err := httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                reqLogger.Error("Failed to fetch GitHub teams", zap.Error(err))
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                reqLogger.Warn("Error fetching teams from GitHub", zap.String("response", string(body)))
                return nil, fmt.Errorf("error fetching teams from GitHub: %s", string(body))
        }</span>

        <span class="cov0" title="0">var githubTeams []struct {
                ID   int    `json:"id"`
                Name string `json:"name"`
        }
        if err := json.NewDecoder(resp.Body).Decode(&amp;githubTeams); err != nil </span><span class="cov0" title="0">{
                reqLogger.Error("Failed to decode GitHub teams", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov0" title="0">var teams []models.Team
        for _, t := range githubTeams </span><span class="cov0" title="0">{
                teams = append(teams, models.Team{
                        ID:   strconv.Itoa(t.ID),
                        Name: t.Name,
                })
        }</span>
        <span class="cov0" title="0">return teams, nil</span>
}

// HandleGitHubLogin godoc
// @Summary GitHub OAuth callback
// @Description Handles the GitHub OAuth callback, exchanges the code for an access token, fetches user info, sets session data, and returns normalized user data and expiration time.
// @Tags github
// @Accept  json
// @Produce  json
// @Param   code query string true "GitHub OAuth authorization code"
// @Success 200 {object} models.LoginResponse "Normalized user data and expiration time"
// @Failure 400 {object} models.SimpleMessageResponse "Missing or invalid code"
// @Failure 403 {object} models.SimpleMessageResponse "Unauthorized org"
// @Failure 500 {object} models.SimpleMessageResponse "Internal server error"
// @Router /oauth/github/callback [get]
func HandleGitHubLogin(c *gin.Context) <span class="cov8" title="1">{
        // Check for the presence of the 'code' query parameter
        code := c.Query("code")
        if code == "" </span><span class="cov8" title="1">{
                logger.Warn("Missing 'code' query parameter in GitHub login")
                c.JSON(http.StatusBadRequest, models.SimpleMessageResponse{Error: "Code query parameter is required"})
                return
        }</span>

        // Get the client ID and secret from global variables
        <span class="cov8" title="1">ctx := context.Background()
        data := url.Values{
                "client_id":     {clientID},
                "client_secret": {clientSecret},
                "code":          {code},
        }
        // Send a POST request to GitHub to exchange the code for an access token
        req, err := http.NewRequestWithContext(ctx, "POST", "https://github.com/login/oauth/access_token", strings.NewReader(data.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create request for GitHub access token", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.SimpleMessageResponse{Error: "Failed to create request for access token"})
                return
        }</span>
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
        req.Header.Set("Accept", "application/json")

        resp, err := httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to fetch GitHub access token", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.SimpleMessageResponse{Error: "Failed to fetch access token"})
                return
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                logger.Warn("Error fetching access token from GitHub", zap.Int("status", resp.StatusCode))
                c.JSON(http.StatusBadRequest, models.SimpleMessageResponse{Error: "Error fetching access token from GitHub"})
                return
        }</span>

        // Decode the response body to get the access token
        <span class="cov8" title="1">var tokenData models.GitHubTokenResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;tokenData); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to decode GitHub token response", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.SimpleMessageResponse{Error: "Failed to decode access token"})
                return
        }</span>

        // Fetch user profile
        <span class="cov8" title="1">githubUser, err := fetchGitHubUserProfile(tokenData.AccessToken)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("Failed to get GitHub user info", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.SimpleMessageResponse{Error: err.Error()})
                return
        }</span>

        // Fetch email if not present in profile
        <span class="cov8" title="1">email := githubUser.Email
        if email == "" </span><span class="cov0" title="0">{
                email, _ = fetchGitHubPrimaryEmail(tokenData.AccessToken)
        }</span>

        <span class="cov8" title="1">normalizedUserData := models.NormalizedUserData{
                ID:        strconv.Itoa(githubUser.ID),
                Name:      githubUser.Login,
                Email:     email,
                AvatarURL: githubUser.AvatarURL,
                Provider:  "github",
        }

        sessionData := map[string]interface{}{
                "token": tokenData.AccessToken,
                "email": email,
                "id":    normalizedUserData.ID,
                "name":  normalizedUserData.Name,
        }

        // Save the session data in the session
        session := sessions.Default(c)
        session.Set("data", sessionData)
        sessioncookie.SplitSessionData(c)

        logger.Debug("Session cookies set successfully for GitHub login", zap.String("user", githubUser.Login))

        // Fetch orgs for the user
        orgReq, err := http.NewRequest("GET", "https://api.github.com/user/orgs", nil)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create request for GitHub orgs", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.SimpleMessageResponse{Error: "Failed to create request for orgs"})
                return
        }</span>
        <span class="cov8" title="1">orgReq.Header.Set("Authorization", tokenData.TokenType+" "+tokenData.AccessToken)
        orgResp, err := httpClient.Do(orgReq)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to fetch GitHub orgs", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.SimpleMessageResponse{Error: "Failed to fetch orgs"})
                return
        }</span>
        <span class="cov8" title="1">defer orgResp.Body.Close()

        var orgs []struct {
                Login string `json:"login"`
        }
        if err := json.NewDecoder(orgResp.Body).Decode(&amp;orgs); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to decode GitHub orgs", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.SimpleMessageResponse{Error: "Failed to decode orgs"})
                return
        }</span>
        <span class="cov8" title="1">orgNames := []string{}
        for _, org := range orgs </span><span class="cov8" title="1">{
                orgNames = append(orgNames, org.Login)
        }</span>
        <span class="cov8" title="1">extraInfo := map[string]any{"orgs": orgNames}

        if !isAllowedUser("github", email, extraInfo) </span><span class="cov8" title="1">{
                logger.Warn("Login attempt from unauthorized GitHub org", zap.String("email", email))
                c.JSON(http.StatusForbidden, models.SimpleMessageResponse{Error: "Unauthorized org"})
                return
        }</span>

        // return the normalized user data and expiration time
        <span class="cov8" title="1">c.JSON(http.StatusOK, models.LoginResponse{
                UserData:  normalizedUserData,
                ExpiresIn: tokenData.ExpiresIn,
        })</span>
}

// GetGithubProfile godoc
// @Summary Get the logged in user's GitHub profile
// @Description Returns the normalized GitHub user profile for the authenticated user.
// @Description Requires one or more cookies named kube_jit_session_&lt;number&gt; (e.g., kube_jit_session_0, kube_jit_session_1).
// @Description Pass split cookies in the Cookie header, for example:
// @Description     -H "Cookie: kube_jit_session_0=${cookie_0};kube_jit_session_1=${cookie_1}"
// @Description Note: Swagger UI cannot send custom Cookie headers due to browser security restrictions. Use curl for testing with split cookies.
// @Tags github
// @Accept  json
// @Produce  json
// @Param   Cookie header string true "Session cookies (multiple allowed, names: kube_jit_session_0, kube_jit_session_1, etc.)"
// @Success 200 {object} models.NormalizedUserData
// @Failure 401 {object} models.SimpleMessageResponse "Unauthorized: no token in session data"
// @Failure 500 {object} models.SimpleMessageResponse "Internal server error"
// @Router /github/profile [get]
func GetGithubProfile(c *gin.Context) <span class="cov0" title="0">{
        // Check if the user is logged in
        sessionData := GetSessionData(c)
        reqLogger := RequestLogger(c)

        token, ok := sessionData["token"].(string)
        if !ok || token == "" </span><span class="cov0" title="0">{
                reqLogger.Warn("No token in session data for GitHub profile")
                c.JSON(http.StatusUnauthorized, models.SimpleMessageResponse{Error: "Unauthorized: no token in session data"})
                return
        }</span>

        <span class="cov0" title="0">githubUser, err := fetchGitHubUserProfile(token)
        if err != nil </span><span class="cov0" title="0">{
                reqLogger.Error("Failed to fetch GitHub user profile", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.SimpleMessageResponse{Error: err.Error()})
                return
        }</span>

        <span class="cov0" title="0">email := githubUser.Email
        if email == "" </span><span class="cov0" title="0">{
                email, _ = fetchGitHubPrimaryEmail(token)
        }</span>

        <span class="cov0" title="0">normalizedUserData := models.NormalizedUserData{
                ID:        strconv.Itoa(githubUser.ID),
                Name:      githubUser.Login,
                Email:     email,
                AvatarURL: githubUser.AvatarURL,
                Provider:  "github",
        }

        c.JSON(http.StatusOK, normalizedUserData)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package handlers

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "kube-jit/internal/models"
        "kube-jit/pkg/sessioncookie"
        "kube-jit/pkg/utils"
        "net/http"
        "strings"
        "sync"
        "time"

        "github.com/gin-contrib/sessions"
        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
        "golang.org/x/oauth2"
        admin "google.golang.org/api/admin/directory/v1"
        "google.golang.org/api/iamcredentials/v1"
        "google.golang.org/api/option"
)

var (
        gsaEmail     string
        gsaEmailErr  error
        gsaEmailOnce sync.Once
        adminEmail   string
)

func init() <span class="cov8" title="1">{
        // Set the admin email for Google Workspace
        // This email is used to impersonate the user to read their groups
        if oauthProvider == "google" </span><span class="cov0" title="0">{
                adminEmail = utils.MustGetEnv("GOOGLE_ADMIN_EMAIL")
        }</span>
}

// getGoogleOAuthConfig constructs and returns the Google OAuth2 config.
// This ensures it uses the current values of clientID, clientSecret, etc.
var getGoogleOAuthConfig = func() *oauth2.Config <span class="cov0" title="0">{
        return &amp;oauth2.Config{
                ClientID:     clientID,     // Reads current package-level clientID from common.go
                ClientSecret: clientSecret, // Reads current package-level clientSecret from common.go
                RedirectURL:  redirectUri,  // Reads current package-level redirectUri from common.go
                Scopes: []string{
                        "https://www.googleapis.com/auth/userinfo.profile",
                        "https://www.googleapis.com/auth/userinfo.email",
                },
                Endpoint: oauth2.Endpoint{
                        AuthURL:  "https://accounts.google.com/o/oauth2/auth",
                        TokenURL: "https://oauth2.googleapis.com/token", // This will be the default
                },
        }
}</span>

// Helper to fetch and decode Google user profile
var fetchGoogleUserProfile = func(token string) (*models.GoogleUser, error) <span class="cov0" title="0">{
        client := oauth2.NewClient(context.Background(), oauth2.StaticTokenSource(&amp;oauth2.Token{AccessToken: token}))
        resp, err := client.Get("https://www.googleapis.com/oauth2/v2/userinfo")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch Google user info: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, fmt.Errorf("error fetching user profile from Google: %s", string(body))
        }</span>

        <span class="cov0" title="0">var googleUser models.GoogleUser
        if err := json.NewDecoder(resp.Body).Decode(&amp;googleUser); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode Google user info: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;googleUser, nil</span>
}

// getGSAEmail retrieves the Google Service Account (GSA) email from the metadata server
func getGSAEmail(reqLogger *zap.Logger) (string, error) <span class="cov0" title="0">{

        gsaEmailOnce.Do(func() </span><span class="cov0" title="0">{
                req, err := http.NewRequest("GET", "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/email", nil)
                if err != nil </span><span class="cov0" title="0">{
                        reqLogger.Error("Failed to create request for GSA email", zap.Error(err))
                        gsaEmailErr = err
                        return
                }</span>
                <span class="cov0" title="0">req.Header.Add("Metadata-Flavor", "Google")

                resp, err := http.DefaultClient.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        reqLogger.Error("Failed to fetch GSA email from metadata server", zap.Error(err))
                        gsaEmailErr = err
                        return
                }</span>
                <span class="cov0" title="0">defer resp.Body.Close()

                body, err := io.ReadAll(resp.Body)
                if err != nil </span><span class="cov0" title="0">{
                        reqLogger.Error("Failed to read GSA email response body", zap.Error(err))
                        gsaEmailErr = err
                        return
                }</span>

                <span class="cov0" title="0">gsaEmail = string(body)</span>
        })

        <span class="cov0" title="0">return gsaEmail, gsaEmailErr</span>
}

// GetGoogleGroupsWithWorkloadIdentity retrieves the Google Groups for a user using Workload Identity
var GetGoogleGroupsWithWorkloadIdentity = func(userEmail string, reqLogger *zap.Logger) ([]models.Team, error) <span class="cov0" title="0">{
        ctx := context.Background()

        serviceAccountEmail, err := getGSAEmail(reqLogger)
        if err != nil </span><span class="cov0" title="0">{
                reqLogger.Error("Failed to get GSA email", zap.Error(err))
                return nil, fmt.Errorf("failed to get GSA email")
        }</span>

        <span class="cov0" title="0">iamService, err := iamcredentials.NewService(ctx)
        if err != nil </span><span class="cov0" title="0">{
                reqLogger.Error("Failed to create IAM credentials service", zap.Error(err))
                return nil, fmt.Errorf("failed to create IAM credentials service")
        }</span>

        <span class="cov0" title="0">now := time.Now()
        claims := map[string]interface{}{
                "iss":   serviceAccountEmail,
                "sub":   adminEmail, // The email of the admin user to impersonate
                "aud":   "https://oauth2.googleapis.com/token",
                "scope": "https://www.googleapis.com/auth/admin.directory.group.readonly",
                "iat":   now.Unix(),
                "exp":   now.Add(time.Hour).Unix(),
        }

        claimsJSON, err := json.Marshal(claims)
        if err != nil </span><span class="cov0" title="0">{
                reqLogger.Error("Failed to marshal JWT claims", zap.Error(err))
                return nil, fmt.Errorf("failed to marshal claims")
        }</span>

        <span class="cov0" title="0">name := fmt.Sprintf("projects/-/serviceAccounts/%s", serviceAccountEmail)
        signJwtRequest := &amp;iamcredentials.SignJwtRequest{
                Payload: string(claimsJSON),
        }

        signJwtResponse, err := iamService.Projects.ServiceAccounts.SignJwt(name, signJwtRequest).Do()
        if err != nil </span><span class="cov0" title="0">{
                reqLogger.Error("Failed to sign JWT", zap.Error(err))
                return nil, fmt.Errorf("failed to sign JWT")
        }</span>

        <span class="cov0" title="0">signedJwt := signJwtResponse.SignedJwt

        resp, err := http.Post(
                "https://oauth2.googleapis.com/token",
                "application/x-www-form-urlencoded",
                strings.NewReader(fmt.Sprintf("grant_type=urn:ietf:params:oauth:grant-type:jwt-bearer&amp;assertion=%s", signedJwt)),
        )
        if err != nil </span><span class="cov0" title="0">{
                reqLogger.Error("Failed to exchange JWT for access token", zap.Error(err))
                return nil, fmt.Errorf("failed to exchange JWT for access token")
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, _ := io.ReadAll(resp.Body)

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                reqLogger.Error("Failed to get token from Google", zap.String("response", string(body)))
                return nil, fmt.Errorf("failed to get token")
        }</span>

        <span class="cov0" title="0">var tokenResp struct {
                AccessToken string `json:"access_token"`
                ExpiresIn   int    `json:"expires_in"`
                TokenType   string `json:"token_type"`
        }
        if err := json.Unmarshal(body, &amp;tokenResp); err != nil </span><span class="cov0" title="0">{
                reqLogger.Error("Failed to parse token response", zap.Error(err))
                return nil, fmt.Errorf("failed to parse token response")
        }</span>

        <span class="cov0" title="0">tokenSource := oauth2.StaticTokenSource(&amp;oauth2.Token{
                AccessToken: tokenResp.AccessToken,
        })
        service, err := admin.NewService(ctx, option.WithTokenSource(tokenSource))
        if err != nil </span><span class="cov0" title="0">{
                reqLogger.Error("Failed to create Admin SDK service", zap.Error(err))
                return nil, fmt.Errorf("failed to create Admin SDK service")
        }</span>

        <span class="cov0" title="0">groupsCall := service.Groups.List().UserKey(userEmail)
        groupsResponse, err := groupsCall.Do()
        if err != nil </span><span class="cov0" title="0">{
                reqLogger.Error("Failed to list Google groups", zap.Error(err))
                return nil, fmt.Errorf("failed to list groups")
        }</span>

        <span class="cov0" title="0">var teams []models.Team
        for _, group := range groupsResponse.Groups </span><span class="cov0" title="0">{
                teams = append(teams, models.Team{
                        Name: group.Name,
                        ID:   group.Email,
                })
        }</span>

        <span class="cov0" title="0">return teams, nil</span>
}

// HandleGoogleLogin godoc
// @Summary Google OAuth callback
// @Description Handles the Google OAuth callback, exchanges the code for an access token, fetches user info, sets session data, and returns normalized user data and expiration time.
// @Tags google
// @Accept  json
// @Produce  json
// @Param   code query string true "Google OAuth authorization code"
// @Success 200 {object} models.LoginResponse "Normalized user data and expiration time"
// @Failure 400 {object} models.SimpleMessageResponse "Missing or invalid code"
// @Failure 403 {object} models.SimpleMessageResponse "Unauthorized domain"
// @Failure 500 {object} models.SimpleMessageResponse "Internal server error"
// @Router /oauth/google/callback [get]
func HandleGoogleLogin(c *gin.Context) <span class="cov8" title="1">{
        code := c.Query("code")

        if code == "" </span><span class="cov0" title="0">{
                logger.Warn("Missing 'code' query parameter in Google login")
                c.JSON(http.StatusBadRequest, models.SimpleMessageResponse{Error: "Code query parameter is required"})
                return
        }</span>

        <span class="cov8" title="1">currentGoogleOAuthConfig := getGoogleOAuthConfig() // Use the function

        token, err := currentGoogleOAuthConfig.Exchange(context.Background(), code)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("Failed to exchange Google token", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.SimpleMessageResponse{Error: "Failed to exchange token"})
                return
        }</span>

        <span class="cov8" title="1">googleUser, err := fetchGoogleUserProfile(token.AccessToken)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to get Google user info", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.SimpleMessageResponse{Error: err.Error()})
                return
        }</span>

        // Check if the user is allowed to log in
        <span class="cov8" title="1">if !isAllowedUser("google", googleUser.Email, nil) </span><span class="cov0" title="0">{
                logger.Warn("Login attempt from unauthorized Google domain", zap.String("email", googleUser.Email))
                c.JSON(http.StatusForbidden, models.SimpleMessageResponse{Error: "Unauthorized domain"})
                return
        }</span>

        <span class="cov8" title="1">normalizedUserData := models.NormalizedUserData{
                ID:        googleUser.ID,
                Name:      googleUser.Name,
                Email:     googleUser.Email,
                AvatarURL: googleUser.Picture,
                Provider:  "google",
        }

        sessionData := map[string]any{
                "id":    googleUser.ID,
                "name":  googleUser.Name,
                "email": googleUser.Email,
                "token": token.AccessToken,
        }

        session := sessions.Default(c)
        session.Set("data", sessionData)

        sessioncookie.SplitSessionData(c)

        logger.Debug("Session cookies set successfully for Google login", zap.String("email", googleUser.Email))

        c.JSON(http.StatusOK, models.LoginResponse{
                UserData:  normalizedUserData,
                ExpiresIn: int(time.Until(token.Expiry).Seconds()),
        })</span>
}

// GetGoogleProfile godoc
// @Summary Get the logged in user's Google profile
// @Description Returns the normalized Google user profile for the authenticated user.
// @Description Requires one or more cookies named kube_jit_session_&lt;number&gt; (e.g., kube_jit_session_0, kube_jit_session_1).
// @Description Pass split cookies in the Cookie header, for example:
// @Description     -H "Cookie: kube_jit_session_0=${cookie_0};kube_jit_session_1=${cookie_1}"
// @Description Note: Swagger UI cannot send custom Cookie headers due to browser security restrictions. Use curl for testing with split cookies.
// @Tags google
// @Accept  json
// @Produce  json
// @Param   Cookie header string true "Session cookies (multiple allowed, names: kube_jit_session_0, kube_jit_session_1, etc.)"
// @Success 200 {object} models.NormalizedUserData
// @Failure 401 {object} models.SimpleMessageResponse "Unauthorized: no token in session data"
// @Failure 500 {object} models.SimpleMessageResponse "Internal server error"
// @Router /google/profile [get]
func GetGoogleProfile(c *gin.Context) <span class="cov8" title="1">{
        // Check if the user is logged
        sessionData := GetSessionData(c)
        reqLogger := RequestLogger(c)

        // Retrieve the token from the session data
        token, ok := sessionData["token"].(string)
        if !ok || token == "" </span><span class="cov0" title="0">{
                reqLogger.Warn("No token in session data for Google profile")
                c.JSON(http.StatusUnauthorized, models.SimpleMessageResponse{Error: "Unauthorized: no token in session data"})
                return
        }</span>

        <span class="cov8" title="1">googleUser, err := fetchGoogleUserProfile(token)
        if err != nil </span><span class="cov0" title="0">{
                reqLogger.Error("Failed to fetch Google user profile", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.SimpleMessageResponse{Error: err.Error()})
                return
        }</span>

        <span class="cov8" title="1">normalizedUserData := map[string]interface{}{
                "id":         googleUser.ID,
                "name":       googleUser.Name,
                "email":      googleUser.Email,
                "avatar_url": googleUser.Picture,
                "provider":   "google",
        }

        c.JSON(http.StatusOK, normalizedUserData)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package handlers

import (
        "go.uber.org/zap"
)

var (
        logger *zap.Logger
)

func InitLogger(l *zap.Logger) <span class="cov8" title="1">{
        logger = l
}</span>

func Logger() *zap.Logger <span class="cov8" title="1">{
        return logger
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package handlers

import (
        "github.com/gin-gonic/gin"
)

// ServeOpenAPI3 serves the OpenAPI 3 YAML spec
func ServeOpenAPI3(c *gin.Context) <span class="cov8" title="1">{
        c.File("/docs/openapi3.yaml")
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package handlers

import (
        "kube-jit/internal/db"
        "kube-jit/internal/models"
        "net/http"
        "sort"
        "time"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// Query the database for pending requests for non-admin users
type PendingRequestRow struct {
        ID            uint      `json:"ID"`
        ClusterName   string    `json:"clusterName"`
        RoleName      string    `json:"roleName"`
        Status        string    `json:"status"`
        UserID        string    `json:"userID"`
        Users         []string  `gorm:"type:jsonb;serializer:json" json:"users"`
        Username      string    `json:"username"`
        Justification string    `json:"justification"`
        StartDate     time.Time `json:"startDate"`
        EndDate       time.Time `json:"endDate"`
        Namespace     string    `json:"namespace"`
        GroupID       string    `json:"groupID"`
        GroupName     string    `json:"groupName"`
        Approved      bool      `json:"approved"`
        CreatedAt     time.Time `json:"CreatedAt"`
}

type PendingRequest struct {
        ID            uint      `json:"ID"`
        ClusterName   string    `json:"clusterName"`
        RoleName      string    `json:"roleName"`
        Status        string    `json:"status"`
        UserID        string    `json:"userID"`
        Users         []string  `json:"users"`
        Username      string    `json:"username"`
        Justification string    `json:"justification"`
        StartDate     time.Time `json:"startDate"`
        EndDate       time.Time `json:"endDate"`
        Namespaces    []string  `json:"namespaces"`
        GroupIDs      []string  `json:"groupIDs"`
        GroupNames    []string  `json:"groupNames"`
        ApprovedList  []bool    `json:"approvedList"`
        CreatedAt     time.Time `json:"CreatedAt"`
}

// PendingApprovalsResponse is used for Swagger docs
type PendingApprovalsResponse struct {
        PendingRequests []PendingRequest `json:"pendingRequests"`
}

// GetPendingApprovals godoc
// @Summary Get pending JIT requests for approver groups
// @Description Returns the pending JIT requests for the authenticated user's approver groups.
// @Description Requires one or more cookies named kube_jit_session_&lt;number&gt; (e.g., kube_jit_session_0, kube_jit_session_1).
// @Description Pass split cookies in the Cookie header, for example:
// @Description     -H "Cookie: kube_jit_session_0=${cookie_0};kube_jit_session_1=${cookie_1}"
// @Description Note: Swagger UI cannot send custom Cookie headers due to browser security restrictions. Use curl for testing with split cookies.
// @Tags records
// @Accept  json
// @Produce  json
// @Param   Cookie header string true "Session cookies (multiple allowed, names: kube_jit_session_0, kube_jit_session_1, etc.)"
// @Success 200 {object} handlers.PendingApprovalsResponse "List of pending requests"
// @Failure 401 {object} models.SimpleMessageResponse "Unauthorized: no approver groups in session"
// @Failure 500 {object} models.SimpleMessageResponse "Failed to fetch pending requests"
// @Router /approvals [get]
func GetPendingApprovals(c *gin.Context) <span class="cov8" title="1">{
        sessionData := GetSessionData(c)
        reqLogger := RequestLogger(c)

        reqLogger.Debug("GetPendingApprovals: Got sessionData", zap.Any("sessionData", sessionData))

        isAdmin, isAdminOk := sessionData["isAdmin"].(bool)
        isPlatformApprover, isPlatformApproverOk := sessionData["isPlatformApprover"].(bool)
        reqLogger.Debug("GetPendingApprovals: Admin/PlatformApprover check", zap.Bool("isAdmin", isAdmin), zap.Bool("isAdminOk", isAdminOk), zap.Bool("isPlatformApprover", isPlatformApprover), zap.Bool("isPlatformApproverOk", isPlatformApproverOk))

        if (isAdminOk &amp;&amp; isAdmin) || (isPlatformApproverOk &amp;&amp; isPlatformApprover) </span><span class="cov8" title="1">{
                reqLogger.Debug("GetPendingApprovals: Admin or Platform Approver path")
                var pendingRequests []models.RequestData // This is a slice of models.RequestData

                if err := db.DB.
                        Where("status = ?", "Requested").
                        Find(&amp;pendingRequests).Error; err != nil </span><span class="cov8" title="1">{
                        c.JSON(http.StatusInternalServerError, models.SimpleMessageResponse{Error: err.Error()})
                        return
                }</span>

                // Ensure pendingRequests is an empty slice if nil, before returning
                <span class="cov8" title="1">if pendingRequests == nil </span><span class="cov0" title="0">{
                        pendingRequests = []models.RequestData{}
                }</span>

                <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"pendingRequests": pendingRequests})
                return</span>
        }

        <span class="cov8" title="1">reqLogger.Debug("GetPendingApprovals: Non-admin path")
        rawApproverGroups, ok := sessionData["approverGroups"]
        reqLogger.Debug("GetPendingApprovals: ApproverGroups check", zap.Any("rawApproverGroups", rawApproverGroups), zap.Bool("ok", ok))

        if !ok </span><span class="cov8" title="1">{
                reqLogger.Info("GetPendingApprovals: No approver groups in session, returning 401")
                c.JSON(http.StatusUnauthorized, models.SimpleMessageResponse{Error: "Unauthorized: no approver groups in session"})
                return
        }</span>

        // Convert approverGroups to a slice of group IDs
        <span class="cov8" title="1">reqLogger.Debug("GetPendingApprovals: Processing approver groups")
        approverGroupIDs := []string{}
        if rawGroups, ok := rawApproverGroups.([]models.Team); ok </span><span class="cov8" title="1">{
                for _, group := range rawGroups </span><span class="cov8" title="1">{
                        approverGroupIDs = append(approverGroupIDs, group.ID)
                }</span>
        } else<span class="cov8" title="1"> if rawGroups, ok := rawApproverGroups.([]any); ok </span><span class="cov8" title="1">{
                for _, group := range rawGroups </span><span class="cov8" title="1">{
                        if groupMap, ok := group.(map[string]any); ok </span><span class="cov8" title="1">{
                                if id, ok := groupMap["id"].(string); ok </span><span class="cov8" title="1">{
                                        approverGroupIDs = append(approverGroupIDs, id)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">if len(approverGroupIDs) == 0 </span><span class="cov8" title="1">{
                reqLogger.Debug("GetPendingApprovals: No approver groups in session, returning 401")
                c.JSON(http.StatusUnauthorized, models.SimpleMessageResponse{Error: "Unauthorized: no approver groups in session"})
                return
        }</span>

        <span class="cov8" title="1">var rows []PendingRequestRow

        if err := db.DB.
                Table("request_data").
                Select(
                        "request_data.id, "+
                                "request_data.cluster_name, "+
                                "request_data.role_name, "+
                                "request_data.user_id, "+
                                "request_data.username, "+
                                "request_data.justification, "+
                                "request_data.start_date, "+
                                "request_data.end_date, "+
                                "request_data.created_at, "+
                                "request_data.users, "+
                                "request_namespaces.namespace, "+
                                "request_namespaces.group_id, "+
                                "request_namespaces.group_name, "+
                                "request_namespaces.approved",
                ).
                Joins("JOIN request_namespaces ON request_namespaces.request_id = request_data.id").
                Where("request_namespaces.group_id IN (?) AND request_data.status = ? AND request_namespaces.approved = false", approverGroupIDs, "Requested").
                Scan(&amp;rows).Error; err != nil </span><span class="cov8" title="1">{
                reqLogger.Error("GetPendingApprovals: Error fetching pending requests", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.SimpleMessageResponse{Error: err.Error()})
                return
        }</span>

        // Group by request ID
        <span class="cov8" title="1">grouped := map[uint]*PendingRequest{}
        for _, row := range rows </span><span class="cov8" title="1">{
                if _, exists := grouped[row.ID]; !exists </span><span class="cov8" title="1">{
                        grouped[row.ID] = &amp;PendingRequest{
                                ID:            row.ID,
                                ClusterName:   row.ClusterName,
                                RoleName:      row.RoleName,
                                Status:        row.Status,
                                UserID:        row.UserID,
                                Users:         row.Users,
                                Username:      row.Username,
                                Justification: row.Justification,
                                StartDate:     row.StartDate,
                                EndDate:       row.EndDate,
                                CreatedAt:     row.CreatedAt,
                                Namespaces:    []string{},
                                GroupIDs:      []string{},
                                GroupNames:    []string{},
                                ApprovedList:  []bool{},
                        }
                }</span>
                <span class="cov8" title="1">grouped[row.ID].Namespaces = append(grouped[row.ID].Namespaces, row.Namespace)
                grouped[row.ID].GroupIDs = append(grouped[row.ID].GroupIDs, row.GroupID)
                grouped[row.ID].GroupNames = append(grouped[row.ID].GroupNames, row.GroupName)
                grouped[row.ID].ApprovedList = append(grouped[row.ID].ApprovedList, row.Approved)</span>
        }

        <span class="cov8" title="1">var pendingRequests []PendingRequest
        for _, v := range grouped </span><span class="cov8" title="1">{
                pendingRequests = append(pendingRequests, *v)
        }</span>

        // Sort pendingRequests by ID to ensure consistent order for the API response
        <span class="cov8" title="1">sort.Slice(pendingRequests, func(i, j int) bool </span><span class="cov8" title="1">{
                return pendingRequests[i].ID &lt; pendingRequests[j].ID
        }</span>)

        <span class="cov8" title="1">if pendingRequests == nil </span><span class="cov8" title="1">{
                pendingRequests = []PendingRequest{}
        }</span>

        <span class="cov8" title="1">reqLogger.Debug("GetPendingApprovals: Returning pending requests", zap.Int("count", len(pendingRequests)))
        c.JSON(http.StatusOK, gin.H{"pendingRequests": pendingRequests})</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package handlers

import (
        "fmt"
        "kube-jit/internal/db"
        "kube-jit/internal/models"
        "kube-jit/pkg/email"
        "kube-jit/pkg/k8s"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// AdminApproveRequest represents the request payload for admin approval
type AdminApproveRequest struct {
        Requests     []models.RequestData `json:"requests"`
        ApproverID   string               `json:"approverID"`
        ApproverName string               `json:"approverName"`
        Status       string               `json:"status"`
}

// Non-admin: expects Namespace string
type UserApproveRequest struct {
        Requests []struct {
                ID            uint      `json:"id"`
                ApproverName  string    `json:"approverName"`
                ClusterName   string    `json:"clusterName"`
                RoleName      string    `json:"roleName"`
                Status        string    `json:"status"`
                UserID        string    `json:"userID"`
                Username      string    `json:"username"`
                Users         []string  `json:"users"`
                Justification string    `json:"justification"`
                StartDate     time.Time `json:"startDate"`
                EndDate       time.Time `json:"endDate"`
                FullyApproved bool      `gorm:"default:false"`
                Namespace     string    `json:"namespace"`
        } `json:"requests"`
        ApproverID   string `json:"approverID"`
        ApproverName string `json:"approverName"`
        Status       string `json:"status"`
}

// SubmitRequestPayload represents the request payload for JIT access
type SubmitRequestPayload struct {
        Role          models.Roles   `json:"role"`
        ClusterName   models.Cluster `json:"cluster"`
        UserID        string         `json:"requestorId"`
        Username      string         `json:"requestorName"`
        Users         []string       `json:"users"`
        Namespaces    []string       `json:"namespaces"`
        Justification string         `json:"justification"`
        StartDate     time.Time      `json:"startDate"`
        EndDate       time.Time      `json:"endDate"`
}

// SubmitRequest godoc
// @Summary Submit a new JIT access request
// @Description Creates a new JIT access request for the authenticated user.
// @Description Requires one or more cookies named kube_jit_session_&lt;number&gt; (e.g., kube_jit_session_0, kube_jit_session_1).
// @Description Pass split cookies in the Cookie header, for example:
// @Description     -H "Cookie: kube_jit_session_0=${cookie_0};kube_jit_session_1=${cookie_1}"
// @Description Note: Swagger UI cannot send custom Cookie headers due to browser security restrictions. Use curl for testing with split cookies.
// @Tags request
// @Accept  json
// @Produce  json
// @Param   Cookie header string true "Session cookies (multiple allowed, names: kube_jit_session_0, kube_jit_session_1, etc.)"
// @Param   request body handlers.SubmitRequestPayload true "JIT request payload"
// @Success 200 {object} models.SimpleMessageResponse "Request submitted successfully"
// @Failure 400 {object} models.SimpleMessageResponse "Invalid request data"
// @Failure 401 {object} models.SimpleMessageResponse "Unauthorized: no token in session data"
// @Failure 500 {object} models.SimpleMessageResponse "Failed to submit request"
// @Router /submit-request [post]
func SubmitRequest(c *gin.Context) <span class="cov8" title="1">{
        // Check if the user is logged in
        sessionData := GetSessionData(c)
        reqLogger := RequestLogger(c)

        // Check if the email is present in the session data
        emailAddress, _ := sessionData["email"].(string)

        // Process the request data
        var requestData SubmitRequestPayload
        if err := c.ShouldBindJSON(&amp;requestData); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.SimpleMessageResponse{Error: "Invalid request data"})
                return
        }</span>

        // Validate namespaces and fetch group IDs and names
        <span class="cov8" title="1">namespaceGroups, err := k8s.ValidateNamespaces(requestData.ClusterName.Name, requestData.Namespaces)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, models.SimpleMessageResponse{Error: fmt.Sprintf("Namespace validation failed: %v", err)})
                return
        }</span>

        // Create a new RequestData in database
        <span class="cov8" title="1">dbRequestData := models.RequestData{
                ClusterName:   requestData.ClusterName.Name,
                RoleName:      requestData.Role.Name,
                Status:        "Requested",
                UserID:        requestData.UserID,
                Username:      requestData.Username,
                Users:         requestData.Users,
                Namespaces:    requestData.Namespaces,
                Justification: requestData.Justification,
                StartDate:     requestData.StartDate,
                EndDate:       requestData.EndDate,
                Email:         emailAddress,
        }

        // Insert the request data into the database
        if err := db.DB.Create(&amp;dbRequestData).Error; err != nil </span><span class="cov0" title="0">{
                reqLogger.Error("Error inserting data in SubmitRequest", zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.SimpleMessageResponse{Error: "Failed to submit request (database error)"})
                return
        }</span>

        // Insert namespaces into the request_namespaces table
        <span class="cov8" title="1">for namespace, groupInfo := range namespaceGroups </span><span class="cov8" title="1">{
                namespaceEntry := models.RequestNamespace{
                        RequestID: dbRequestData.ID,
                        Namespace: namespace,
                        GroupID:   groupInfo.GroupID,
                        GroupName: groupInfo.GroupName,
                        Approved:  false,
                }
                if err := db.DB.Create(&amp;namespaceEntry).Error; err != nil </span><span class="cov0" title="0">{
                        reqLogger.Error("Error inserting namespace data in SubmitRequest", zap.Error(err))
                        c.JSON(http.StatusInternalServerError, models.SimpleMessageResponse{Error: "Failed to submit request (namespace error)"})
                        return
                }</span>
        }

        // Send submission email
        <span class="cov8" title="1">if dbRequestData.Email != "" </span><span class="cov8" title="1">{
                body := email.BuildRequestEmail(email.EmailRequestDetails{
                        Username:      dbRequestData.Username,
                        ClusterName:   dbRequestData.ClusterName,
                        Namespaces:    dbRequestData.Namespaces,
                        RoleName:      dbRequestData.RoleName,
                        Justification: dbRequestData.Justification,
                        StartDate:     dbRequestData.StartDate,
                        EndDate:       dbRequestData.EndDate,
                        Status:        "submitted",
                        Message:       "",
                })
                go func() </span><span class="cov8" title="1">{
                        if err := email.SendMail(dbRequestData.Email, fmt.Sprintf("Your JIT request #%d has been submitted", dbRequestData.ID), body); err != nil </span><span class="cov0" title="0">{
                                reqLogger.Warn("Failed to send submission email", zap.String("email", dbRequestData.Email), zap.Error(err))
                        }</span>
                }()
        }

        // Respond with success message
        <span class="cov8" title="1">c.JSON(http.StatusOK, models.SimpleMessageResponse{Message: "Request submitted successfully"})</span>
}

// ApproveOrRejectRequests godoc
// @Summary Approve or reject JIT access requests
// @Description Approves or rejects pending JIT access requests. Admins and platform approvers can approve/reject multiple requests at once. Non-admins can approve/reject individual namespaces.
// @Description Requires one or more cookies named kube_jit_session_&lt;number&gt; (e.g., kube_jit_session_0, kube_jit_session_1).
// @Description Pass split cookies in the Cookie header, for example:
// @Description     -H "Cookie: kube_jit_session_0=${cookie_0};kube_jit_session_1=${cookie_1}"
// @Description Note: Swagger UI cannot send custom Cookie headers due to browser security restrictions. Use curl for testing with split cookies.
// @Tags request
// @Accept  json
// @Produce  json
// @Param   Cookie header string true "Session cookies (multiple allowed, names: kube_jit_session_0, kube_jit_session_1, etc.)"
// @Param   request body handlers.AdminApproveRequest true "Approval/rejection payload (admins/platform approvers use AdminApproveRequest, non-admins use UserApproveRequest)" example({
// @example AdminApproveRequest:
// @example {
// @example   "approverID": "admin123",
// @example   "approverName": "Admin User",
// @example   "requests": [{
// @example     "ID": 1,
// @example     "userID": "user1",
// @example     "username": "alice",
// @example     "clusterName": "prod",
// @example     "roleName": "admin",
// @example     "namespaces": ["default", "kube-system"],
// @example     "justification": "Need access for deployment",
// @example     "startDate": "2024-05-01T00:00:00Z",
// @example     "endDate": "2024-05-02T00:00:00Z",
// @example     "status": "approved",
// @example     "users": ["alice"]
// @example   }],
// @example   "status": "approved"
// @example }
// @example UserApproveRequest:
// @example {
// @example   "approverID": "user123",
// @example   "approverName": "User",
// @example   "namespaceApprovals": [{
// @example     "namespace": "default",
// @example     "approved": true,
// @example     "approverID": "user123",
// @example     "approverName": "User",
// @example     "groupID": "group1",
// @example     "groupName": "Dev Team"
// @example   },{
// @example     "namespace": "kube-system",
// @example     "approved": false,
// @example     "approverID": "user123",
// @example     "approverName": "User",
// @example     "groupID": "group1",
// @example     "groupName": "Dev Team"
// @example   }],
// @example   "status": "approved"
// @example }
// @Success 200 {object} models.SimpleMessageResponse "Requests processed successfully"
// @Failure 400 {object} models.SimpleMessageResponse "Invalid request format"
// @Failure 401 {object} models.SimpleMessageResponse "Unauthorized: no approver groups in session"
// @Failure 500 {object} models.SimpleMessageResponse "Failed to process requests"
// @Router /approve-reject [post]
func ApproveOrRejectRequests(c *gin.Context) <span class="cov8" title="1">{
        // Check if the user is logged in
        sessionData := GetSessionData(c)
        reqLogger := RequestLogger(c)

        // Check if the user is an admin or platform approver
        isAdmin, _ := sessionData["isAdmin"].(bool)
        isPlatformApprover, _ := sessionData["isPlatformApprover"].(bool)

        var approverGroups []string
        if !isAdmin &amp;&amp; !isPlatformApprover </span><span class="cov0" title="0">{
                // Only non-admins need approverGroups
                rawApproverGroups, ok := sessionData["approverGroups"]
                if !ok </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, models.SimpleMessageResponse{Error: "Unauthorized: no approver groups in session"})
                        return
                }</span>
                // Handle both []models.Team and []interface{} (from session serialization)
                <span class="cov0" title="0">if rawGroups, ok := rawApproverGroups.([]models.Team); ok </span><span class="cov0" title="0">{
                        for _, group := range rawGroups </span><span class="cov0" title="0">{
                                approverGroups = append(approverGroups, group.ID)
                        }</span>
                } else<span class="cov0" title="0"> if rawGroups, ok := rawApproverGroups.([]any); ok </span><span class="cov0" title="0">{
                        for _, group := range rawGroups </span><span class="cov0" title="0">{
                                if groupMap, ok := group.(map[string]any); ok </span><span class="cov0" title="0">{
                                        if id, ok := groupMap["id"].(string); ok </span><span class="cov0" title="0">{
                                                approverGroups = append(approverGroups, id)
                                        }</span>
                                }
                        }
                }
                <span class="cov0" title="0">if len(approverGroups) == 0 </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, models.SimpleMessageResponse{Error: "Unauthorized: no approver groups in session"})
                        return
                }</span>
        }

        <span class="cov8" title="1">if isAdmin || isPlatformApprover </span><span class="cov8" title="1">{
                // Admin/Platform Approver: expects Namespaces []string
                var req AdminApproveRequest
                if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, models.SimpleMessageResponse{Error: "Invalid request format"})
                        return
                }</span>
                <span class="cov8" title="1">for _, r := range req.Requests </span><span class="cov8" title="1">{
                        processApproval(reqLogger, r.ID, r, req.ApproverID, req.ApproverName, req.Status, nil, c)
                }</span>

                <span class="cov8" title="1">c.JSON(http.StatusOK, models.SimpleMessageResponse{Message: "Admin/Platform requests processed successfully"})
                return</span>
        } else<span class="cov0" title="0"> {
                var req UserApproveRequest
                if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, models.SimpleMessageResponse{Error: "Invalid request format"})
                        return
                }</span>
                <span class="cov0" title="0">for _, r := range req.Requests </span><span class="cov0" title="0">{
                        namespaces := []string{r.Namespace}
                        // Convert to models.RequestData for downstream compatibility
                        requestData := models.RequestData{
                                ClusterName:   r.ClusterName,
                                RoleName:      r.RoleName,
                                Status:        r.Status,
                                UserID:        r.UserID,
                                Username:      r.Username,
                                Users:         r.Users,
                                Namespaces:    namespaces,
                                Justification: r.Justification,
                                StartDate:     r.StartDate,
                                EndDate:       r.EndDate,
                                FullyApproved: r.FullyApproved,
                        }
                        processApproval(reqLogger, r.ID, requestData, req.ApproverID, req.ApproverName, req.Status, approverGroups, c)
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusOK, models.SimpleMessageResponse{Message: "User requests processed successfully"})
                return</span>
        }
}

// Helper function to process approval logic for each request
// It updates the request status and approver information in the database
// It also creates the k8s object if all namespaces are approved
// It sends an email notification to the user if the request is approved
func processApproval(
        reqLogger *zap.Logger,
        requestID uint,
        requestData models.RequestData,
        approverID string,
        approverName string,
        status string,
        approverGroups []string,
        c *gin.Context,
) <span class="cov8" title="1">{
        // Fetch namespaces for the request
        var dbNamespaces []models.RequestNamespace
        if err := db.DB.Where("request_id = ?", requestID).Find(&amp;dbNamespaces).Error; err != nil </span><span class="cov0" title="0">{
                reqLogger.Error("Error fetching namespaces for request", zap.Uint("requestID", requestID), zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.SimpleMessageResponse{Error: "Failed to fetch namespaces"})
                return
        }</span>

        // Approve all if admin (approverGroups == nil), else check group
        <span class="cov8" title="1">for i := range dbNamespaces </span><span class="cov8" title="1">{
                ns := &amp;dbNamespaces[i]
                if approverGroups == nil || contains(approverGroups, ns.GroupID) </span><span class="cov8" title="1">{
                        if status == "Approved" </span><span class="cov8" title="1">{
                                ns.Approved = true
                        }</span> else<span class="cov0" title="0"> if status == "Rejected" </span><span class="cov0" title="0">{
                                ns.Approved = false
                        }</span>
                        <span class="cov8" title="1">ns.ApproverID = approverID
                        ns.ApproverName = approverName
                        if err := db.DB.Save(ns).Error; err != nil </span><span class="cov0" title="0">{
                                reqLogger.Error("Error updating namespace approval", zap.Uint("requestID", requestID), zap.String("namespace", ns.Namespace), zap.Error(err))
                                c.JSON(http.StatusInternalServerError, models.SimpleMessageResponse{Error: "Failed to update namespace approval"})
                                return
                        }</span>
                } else<span class="cov0" title="0"> {
                        reqLogger.Info("Skipping namespace - approver does not have permissions",
                                zap.String("namespace", ns.Namespace),
                                zap.String("groupID", ns.GroupID),
                                zap.String("approverID", approverID),
                        )
                }</span>
        }

        // Check if all namespaces for the request are approved
        <span class="cov8" title="1">allApproved := true
        for _, ns := range dbNamespaces </span><span class="cov8" title="1">{
                if !ns.Approved </span><span class="cov0" title="0">{
                        allApproved = false
                        break</span>
                }
        }

        // Only set status to "Approved" if all namespaces are approved, otherwise keep as "Requested"
        <span class="cov8" title="1">finalStatus := status
        if status == "Approved" &amp;&amp; !allApproved </span><span class="cov0" title="0">{
                finalStatus = "Requested"
        }</span>

        <span class="cov8" title="1">reqLogger.Debug("Approval status check",
                zap.Bool("allApproved", allApproved),
                zap.String("status", status),
                zap.String("finalStatus", finalStatus),
                zap.Uint("requestID", requestID),
        )

        if allApproved &amp;&amp; status == "Approved" </span><span class="cov8" title="1">{
                var namespacesToSpec []string
                for _, ns := range dbNamespaces </span><span class="cov8" title="1">{
                        namespacesToSpec = append(namespacesToSpec, ns.Namespace)
                }</span>
                <span class="cov8" title="1">requestData.Namespaces = namespacesToSpec
                requestData.ID = requestID
                if err := k8s.CreateK8sObject(requestData, approverName); err != nil </span><span class="cov0" title="0">{
                        reqLogger.Error("Error creating k8s object for request", zap.Uint("requestID", requestID), zap.Error(err))
                        c.JSON(http.StatusInternalServerError, models.SimpleMessageResponse{Error: "Failed to create k8s object"})
                        return
                }</span>
        }

        // Fetch the request record
        <span class="cov8" title="1">var req models.RequestData
        if err := db.DB.First(&amp;req, requestID).Error; err != nil </span><span class="cov0" title="0">{
                reqLogger.Error("Error fetching request for update", zap.Uint("requestID", requestID), zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.SimpleMessageResponse{Error: "Failed to fetch request"})
                return
        }</span>

        // Append approver if not already present
        <span class="cov8" title="1">if !contains(req.ApproverIDs, approverID) </span><span class="cov8" title="1">{
                req.ApproverIDs = append(req.ApproverIDs, approverID)
        }</span>
        <span class="cov8" title="1">if !contains(req.ApproverNames, approverName) </span><span class="cov8" title="1">{
                req.ApproverNames = append(req.ApproverNames, approverName)
        }</span>

        // Update the request status and approvers using struct update
        <span class="cov8" title="1">req.Status = finalStatus
        req.FullyApproved = allApproved

        if err := db.DB.Model(&amp;req).Select("Status", "ApproverIDs", "ApproverNames", "FullyApproved").Updates(req).Error; err != nil </span><span class="cov0" title="0">{
                reqLogger.Error("Error updating request after approval", zap.Uint("requestID", requestID), zap.Error(err))
                c.JSON(http.StatusInternalServerError, models.SimpleMessageResponse{Error: "Failed to update request"})
                return
        }</span>

        <span class="cov8" title="1">if req.Email != "" </span><span class="cov8" title="1">{
                body := email.BuildRequestEmail(email.EmailRequestDetails{
                        Username:      req.Username,
                        ClusterName:   req.ClusterName,
                        Namespaces:    req.Namespaces,
                        RoleName:      req.RoleName,
                        Justification: req.Justification,
                        StartDate:     req.StartDate,
                        EndDate:       req.EndDate,
                        Status:        req.Status,
                        Message:       "", // Reserved for controller messages
                })
                go func() </span><span class="cov8" title="1">{
                        if err := email.SendMail(req.Email, fmt.Sprintf("Your JIT request #%d is now %s", req.ID, req.Status), body); err != nil </span><span class="cov0" title="0">{
                                reqLogger.Warn("Failed to send status change email", zap.String("email", req.Email), zap.Error(err))
                        }</span>
                }()
        }
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package middleware

import (
        "time"

        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// AccessLogger is a middleware that logs the access details of each request
// It logs the request method, path, query parameters, client IP, user agent, latency, and user information
func AccessLogger(logger *zap.Logger) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                start := time.Now()
                c.Next()
                latency := time.Since(start)

                userID, _ := c.Get("userID")
                username, _ := c.Get("username")

                logger.Info("access",
                        zap.Int("status", c.Writer.Status()),
                        zap.String("method", c.Request.Method),
                        zap.String("path", c.Request.URL.Path),
                        zap.String("query", c.Request.URL.RawQuery),
                        zap.String("ip", c.ClientIP()),
                        zap.String("user-agent", c.Request.UserAgent()),
                        zap.Duration("latency", latency),
                        zap.String("userID", userIDString(userID)),
                        zap.String("username", usernameString(username)),
                        zap.Time("time", time.Now()),
                )
        }</span>
}

// userIDString converts the userID to a string, if possible
// Otherwise, it returns an empty string
func userIDString(val interface{}) string <span class="cov8" title="1">{
        if s, ok := val.(string); ok </span><span class="cov8" title="1">{
                return s
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// usernameString converts the username to a string, if possible
// Otherwise, it returns an empty string
func usernameString(val interface{}) string <span class="cov8" title="1">{
        if s, ok := val.(string); ok </span><span class="cov8" title="1">{
                return s
        }</span>
        <span class="cov8" title="1">return ""</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package middleware

import (
        "net/http"

        "github.com/gin-contrib/sessions"
        "github.com/gin-gonic/gin"
)

// RequireAuth is a middleware that checks if the user is authenticated.
// It retrieves session data from cookies and sets it in the context.
// If the session data is not found or invalid, it returns an unauthorized response.
// It also sets user ID and username in the context for logging purposes.
func RequireAuth() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                session := sessions.Default(c)
                combinedData := session.Get("data")
                if combinedData == nil </span><span class="cov8" title="1">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized: no session data in cookies"})
                        c.Abort()
                        return
                }</span>
                <span class="cov8" title="1">sessionData, ok := combinedData.(map[string]interface{})
                if !ok </span><span class="cov8" title="1">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid session data format"})
                        c.Abort()
                        return
                }</span>
                <span class="cov8" title="1">c.Set("sessionData", sessionData)
                if id, ok := sessionData["id"].(string); ok </span><span class="cov8" title="1">{
                        c.Set("userID", id)
                }</span>
                <span class="cov8" title="1">if name, ok := sessionData["name"].(string); ok </span><span class="cov8" title="1">{
                        c.Set("username", name)
                }</span>
                <span class="cov8" title="1">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package middleware

import (
        "go.uber.org/zap"
)

var (
        logger *zap.Logger
)

func InitLogger(l *zap.Logger) <span class="cov8" title="1">{
        logger = l
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package middleware

import (
        "encoding/json"
        "kube-jit/pkg/sessioncookie"
        "kube-jit/pkg/utils"
        "time"

        "github.com/gin-contrib/cors"
        "github.com/gin-contrib/sessions"
        "github.com/gin-contrib/sessions/cookie"
        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

// SetupMiddleware sets up the middleware for the Gin engine
func SetupMiddleware(r *gin.Engine) <span class="cov8" title="1">{
        // Get allowed origins from env var ALLOW_ORIGINS
        var allowOrigins []string
        allowOriginsStr := utils.MustGetEnv("ALLOW_ORIGINS")
        if err := json.Unmarshal([]byte(allowOriginsStr), &amp;allowOrigins); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to parse ALLOW_ORIGINS env var", zap.Error(err))
                panic(err)</span>
        }

        // CORS middleware
        <span class="cov8" title="1">r.Use(cors.New(cors.Config{
                AllowOrigins:     allowOrigins,
                AllowCredentials: true,
                AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
                AllowHeaders:     []string{"Content-Type", "Authorization"},
                ExposeHeaders:    []string{"Content-Length"},
                MaxAge:           12 * time.Hour,
        }))

        // Session middleware with custom logic
        cookieSecret := utils.MustGetEnv("HMAC_SECRET")
        store := cookie.NewStore([]byte(cookieSecret))
        r.Use(sessions.Sessions("mysession", store))
        r.Use(sessioncookie.SplitAndCombineSessionMiddleware())

        logger.Info("Middleware setup complete", zap.Strings("allowOrigins", allowOrigins))</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package routes

import (
        "kube-jit/internal/handlers"
        "kube-jit/internal/middleware"
        "kube-jit/pkg/sessioncookie"

        _ "kube-jit/docs"

        "github.com/gin-gonic/gin"
        swaggerFiles "github.com/swaggo/files"
        ginSwagger "github.com/swaggo/gin-swagger"
)

func SetupRoutes(r *gin.Engine) <span class="cov8" title="1">{
        // Routes that require session handling - authenticated
        // This middleware will check for the session cookie and handle it accordingly
        // We are using a custoim middleware to split and combine the session cookie
        apiWithSession := r.Group("/kube-jit-api")
        apiWithSession.Use(sessioncookie.SplitAndCombineSessionMiddleware())
        apiWithSession.Use(middleware.RequireAuth())
        // log the user ID and username from the session data
        apiWithSession.Use(middleware.AccessLogger(handlers.Logger()))
        </span><span class="cov8" title="1">{
                apiWithSession.GET("/approving-groups", handlers.GetApprovingGroups)
                apiWithSession.GET("/roles-and-clusters", handlers.GetClustersAndRoles)
                apiWithSession.GET("/github/profile", handlers.GetGithubProfile)
                apiWithSession.GET("/google/profile", handlers.GetGoogleProfile)
                apiWithSession.GET("/azure/profile", handlers.GetAzureProfile)
                apiWithSession.POST("/submit-request", handlers.SubmitRequest)
                apiWithSession.GET("/history", handlers.GetRecords)
                apiWithSession.GET("/approvals", handlers.GetPendingApprovals)
                apiWithSession.POST("/approve-reject", handlers.ApproveOrRejectRequests)
                apiWithSession.POST("/permissions", handlers.CommonPermissions)
                apiWithSession.POST("/admin/clean-expired", handlers.CleanExpiredRequests)
        }</span>

        // Routes that do NOT require session handling - unauthenticated
        <span class="cov8" title="1">r.GET("/kube-jit-api/docs/openapi3.yaml", handlers.ServeOpenAPI3)
        r.GET("/kube-jit-api/oauth/github/callback", handlers.HandleGitHubLogin)
        r.GET("/kube-jit-api/oauth/google/callback", handlers.HandleGoogleLogin)
        r.GET("/kube-jit-api/oauth/azure/callback", handlers.HandleAzureLogin)
        r.GET("/kube-jit-api/healthz", handlers.HealthCheck)
        r.GET("/kube-jit-api/client_id", handlers.GetOauthClientId)
        r.POST("/k8s-callback", handlers.K8sCallback)
        r.POST("/kube-jit-api/logout", handlers.Logout)
        r.GET("/kube-jit-api/build-sha", handlers.GetBuildSha)
        // openapi v2
        r.GET("/kube-jit-api/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
        // openapi v3
        r.Static("/kube-jit-api/swagger-ui", "/swagger-ui")</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package email

import (
        "kube-jit/pkg/utils"
        "strconv"

        "gopkg.in/gomail.v2"
)

// SendMail sends an email using the SMTP server configured in the environment variables.
// It takes the recipient's email address, subject, and body of the email as parameters.
// It returns an error if the email could not be sent.
var SendMail = func(to, subject, body string) error <span class="cov0" title="0">{
        m := gomail.NewMessage()
        m.SetHeader("From", utils.MustGetEnv("SMTP_FROM"))
        m.SetHeader("To", to)
        m.SetHeader("Subject", subject)
        m.SetBody("text/html", body)

        d := gomail.NewDialer(
                utils.MustGetEnv("SMTP_HOST"),
                mustAtoi(utils.MustGetEnv("SMTP_PORT")),
                utils.GetEnv("SMTP_USER", ""),
                utils.GetEnv("SMTP_PASS", ""),
        )
        return d.DialAndSend(m)
}</span>

// mustAtoi is a helper function that converts a string to an integer.
func mustAtoi(s string) int <span class="cov0" title="0">{
        i, _ := strconv.Atoi(s)
        return i
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package email

import (
        "fmt"
        "os"
        "strings"
        "time"

        "golang.org/x/text/cases"
        "golang.org/x/text/language"
)

var emailLoc *time.Location

func init() <span class="cov8" title="1">{
        locName := os.Getenv("EMAIL_TIMEZONE")
        if locName == "" </span><span class="cov8" title="1">{
                locName = "Europe/London" // default fallback
        }</span>
        <span class="cov8" title="1">var err error
        emailLoc, err = time.LoadLocation(locName)
        if err != nil </span><span class="cov0" title="0">{
                emailLoc = time.UTC // fallback to UTC if invalid
        }</span>
}

// EmailRequestDetails holds the details for the email template
type EmailRequestDetails struct {
        Username      string
        ClusterName   string
        Namespaces    []string
        RoleName      string
        Justification string
        StartDate     time.Time
        EndDate       time.Time
        Status        string
        Message       string // extra notes or custom message
}

// BuildRequestEmail generates an HTML email template for a JIT access request
// It includes details such as the username, cluster name, namespaces, role name,
// justification, start and end dates, status, and any additional message
// The email is styled with inline CSS for better compatibility across email clients
// The function returns the generated HTML string
func BuildRequestEmail(details EmailRequestDetails) string <span class="cov8" title="1">{
        caser := cases.Title(language.English)
        startLocal := details.StartDate.In(emailLoc)
        endLocal := details.EndDate.In(emailLoc)
        return fmt.Sprintf(`
        &lt;div style="font-family: Arial, sans-serif; max-width: 600px; margin: auto; border:1px solid #e0e0e0; border-radius:8px; overflow:hidden;"&gt;
            &lt;div style="background: #1b4fa4; color: #fff; padding: 18px 24px;"&gt;
                &lt;h2 style="margin:0; font-size: 1.3em;"&gt;JIT Access Request - %s&lt;/h2&gt;
            &lt;/div&gt;
            &lt;div style="background: #f9f9f9; padding: 24px;"&gt;
                &lt;p style="font-size: 1.1em; margin-bottom: 18px;"&gt;
                    Hello &lt;b&gt;%s&lt;/b&gt;,
                &lt;/p&gt;
                &lt;p style="margin-bottom: 18px;"&gt;
                    Your request for &lt;b&gt;cluster:&lt;/b&gt; %s&lt;br&gt;
                    &lt;b&gt;Namespaces:&lt;/b&gt; %s&lt;br&gt;
                    &lt;b&gt;Role:&lt;/b&gt; %s&lt;br&gt;
                    &lt;b&gt;Status:&lt;/b&gt; &lt;span style="color: #1b4fa4; font-weight: bold;"&gt;%s&lt;/span&gt;
                &lt;/p&gt;
                &lt;p style="margin-bottom: 18px;"&gt;
                    &lt;b&gt;Justification:&lt;/b&gt; %s&lt;br&gt;
                    &lt;b&gt;Start:&lt;/b&gt; %s&lt;br&gt;
                    &lt;b&gt;End:&lt;/b&gt; %s
                &lt;/p&gt;
                %s
            &lt;/div&gt;
            &lt;div style="background: #f1f1f1; color: #888; font-size: 0.95em; padding: 10px 24px;"&gt;
                This is an automated notification from Kube-JIT.
            &lt;/div&gt;
        &lt;/div&gt;
    `,
                caser.String(details.Status),
                details.Username,
                details.ClusterName,
                strings.Join(details.Namespaces, ", "),
                details.RoleName,
                caser.String(details.Status),
                details.Justification,
                startLocal.Format("2006-01-02 15:04 MST"),
                endLocal.Format("2006-01-02 15:04 MST"),
                func() string </span><span class="cov8" title="1">{
                        if details.Message != "" </span><span class="cov8" title="1">{
                                return fmt.Sprintf(`&lt;div style="margin-top: 18px; padding: 12px; background: #fffbe6; border-left: 4px solid #ffe066;"&gt;&lt;b&gt;Notes:&lt;/b&gt; %s&lt;/div&gt;`, details.Message)
                        }</span>
                        <span class="cov8" title="1">return ""</span>
                }(),
        )
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package k8s

import (
        "context"
        "encoding/base64"
        "fmt"
        "kube-jit/internal/models"
        "sync"
        "time"

        containerapiv1 "cloud.google.com/go/container/apiv1"
        "cloud.google.com/go/container/apiv1/containerpb"
        "github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
        "github.com/Azure/azure-sdk-for-go/sdk/azidentity"
        "github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/containerservice/armcontainerservice"
        "go.uber.org/zap"
        "golang.org/x/oauth2/google"
        "google.golang.org/api/container/v1"
        "k8s.io/client-go/dynamic"
        "k8s.io/client-go/rest"
        "k8s.io/client-go/tools/clientcmd"
        // imports...
)

var dynamicClientCache sync.Map

// Use dynamic.Interface, not *dynamic.DynamicClient
var dynamicNewForConfig = func(config *rest.Config) (dynamic.Interface, error) <span class="cov0" title="0">{
        return dynamic.NewForConfig(config)
}</span>

type CachedClient struct {
        Client       dynamic.Interface
        TokenExpires int64
}

// createDynamicClient creates and returns a dynamic client based on cluster in request
// It caches the client and token expiration time to avoid creating a new client for each request
// It also invalidates the JitGroups cache if the token is expired
// It uses the cluster type to determine how to create the client (GKE, AKS, or generic)
// It uses the Google Cloud SDK for GKE and Azure SDK for AKS
// It uses the Kubernetes client-go library for generic clusters
var createDynamicClient = func(req models.RequestData) dynamic.Interface <span class="cov8" title="1">{
        // Check if the dynamic client for the cluster is already cached
        if cached, exists := dynamicClientCache.Load(req.ClusterName); exists </span><span class="cov8" title="1">{
                cachedClient := cached.(*CachedClient)
                currentTime := time.Now().Unix()

                // Check if the token is expired
                if cachedClient.TokenExpires &gt; currentTime </span><span class="cov8" title="1">{
                        logger.Info("Using cached dynamic client for cluster", zap.String("cluster", req.ClusterName), zap.Int64("expires", cachedClient.TokenExpires))
                        return cachedClient.Client
                }</span>

                <span class="cov8" title="1">logger.Info("Token expired for cluster, refreshing client", zap.String("cluster", req.ClusterName))
                InvalidateJitGroupsCache(req.ClusterName)</span> // Invalidate the JitGroups cache
        }

        // Get the cluster configuration
        <span class="cov8" title="1">selectedCluster := ClusterConfigs[req.ClusterName]

        var restConfig *rest.Config
        var err error
        var tokenExpires int64

        // Use a switch statement to handle different cluster types
        switch selectedCluster.Type </span>{
        case "gke":<span class="cov0" title="0"> // Google Kubernetes Engine
                logger.Info("Using Google Cloud SDK to access GKE cluster", zap.String("cluster", req.ClusterName))
                // GKE-specific logic
                ctx := context.Background()
                credentials, err := google.FindDefaultCredentials(ctx, container.CloudPlatformScope)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to get default credentials", zap.Error(err))
                }</span>
                <span class="cov0" title="0">tokenSource := credentials.TokenSource

                client, err := containerapiv1.NewClusterManagerClient(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to create GKE client", zap.Error(err))
                }</span>
                <span class="cov0" title="0">defer client.Close()

                location := selectedCluster.Region
                clusterName := fmt.Sprintf("projects/%s/locations/%s/clusters/%s", selectedCluster.ProjectID, location, selectedCluster.Name)
                cluster, err := client.GetCluster(ctx, &amp;containerpb.GetClusterRequest{Name: clusterName})
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to get GKE cluster details", zap.Error(err))
                }</span>

                <span class="cov0" title="0">clusterEndpoint := cluster.Endpoint
                caCertificate := cluster.MasterAuth.ClusterCaCertificate
                decodedCACertificate, err := base64.StdEncoding.DecodeString(caCertificate)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to decode CA certificate", zap.Error(err))
                }</span>

                <span class="cov0" title="0">token, err := tokenSource.Token()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to get OAuth2 token", zap.Error(err))
                }</span>

                <span class="cov0" title="0">restConfig = &amp;rest.Config{
                        Host:        "https://" + clusterEndpoint,
                        BearerToken: token.AccessToken,
                        TLSClientConfig: rest.TLSClientConfig{
                                CAData: decodedCACertificate,
                        },
                }
                // Set token expiration time (e.g., 5 minutes before actual expiration)
                tokenExpires = token.Expiry.Unix() - 300</span>

        case "aks":<span class="cov0" title="0"> // Azure Kubernetes Service
                logger.Info("Using Azure SDK to access AKS cluster", zap.String("cluster", req.ClusterName))
                // AKS-specific logic
                cred, err := azidentity.NewDefaultAzureCredential(nil)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to create Azure credential", zap.Error(err))
                }</span>
                <span class="cov0" title="0">adminClient, err := armcontainerservice.NewManagedClustersClient(selectedCluster.ProjectID, cred, nil)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to create AKS AdminCredentialsClient", zap.Error(err))
                }</span>
                <span class="cov0" title="0">kubeconfigResp, err := adminClient.ListClusterUserCredentials(context.Background(), selectedCluster.Region, selectedCluster.Name, nil)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to get AKS cluster user credentials", zap.Error(err))
                }</span>
                <span class="cov0" title="0">kubeconfigData := kubeconfigResp.Kubeconfigs[0].Value
                config, err := clientcmd.Load(kubeconfigData)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to parse kubeconfig", zap.Error(err))
                }</span>
                <span class="cov0" title="0">cluster := config.Clusters[config.Contexts[config.CurrentContext].Cluster]
                clusterEndpoint := cluster.Server
                caCertificate := cluster.CertificateAuthorityData

                token, err := cred.GetToken(context.Background(), policy.TokenRequestOptions{
                        Scopes: []string{"6dae42f8-4368-4678-94ff-3960e28e3630/.default"},
                })
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to get AAD token", zap.Error(err))
                }</span>

                <span class="cov0" title="0">restConfig = &amp;rest.Config{
                        Host:        clusterEndpoint,
                        BearerToken: token.Token,
                        TLSClientConfig: rest.TLSClientConfig{
                                CAData: caCertificate,
                        },
                }
                // Set token expiration time (e.g., 1 hour)
                tokenExpires = time.Now().Add(1 * time.Hour).Unix()</span>

        default:<span class="cov8" title="1"> // Generic Kubernetes cluster
                logger.Info("Using generic configuration for cluster", zap.String("cluster", req.ClusterName))
                // Generic cluster logic
                apiServerURL := selectedCluster.Host
                saToken := selectedCluster.Token
                caData, err := base64.StdEncoding.DecodeString(selectedCluster.CA)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to decode CA certificate", zap.Error(err))
                }</span>
                <span class="cov8" title="1">restConfig = &amp;rest.Config{
                        Host:        apiServerURL,
                        BearerToken: saToken,
                        TLSClientConfig: rest.TLSClientConfig{
                                Insecure: selectedCluster.Insecure,
                                CAData:   caData,
                        },
                }
                // Non-GKE clusters don't use token expiration
                tokenExpires = time.Now().Add(24 * time.Hour).Unix()</span> // Arbitrary long expiration
        }

        // Create the dynamic client
        <span class="cov8" title="1">dynamicClient, err := dynamicNewForConfig(restConfig)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to create k8s client", zap.Error(err))
        }</span>

        // Cache the dynamic client with expiration
        <span class="cov8" title="1">dynamicClientCache.Store(req.ClusterName, &amp;CachedClient{
                Client:       dynamicClient,
                TokenExpires: tokenExpires,
        })
        logger.Info("Cached dynamic client for cluster", zap.String("cluster", req.ClusterName))
        return dynamicClient</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package k8s

import (
        "context"
        "kube-jit/internal/models"
        "kube-jit/pkg/utils"
        "os"

        "go.uber.org/zap"
        "gopkg.in/yaml.v2"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/rest"
        "k8s.io/client-go/tools/clientcmd"
)

var (
        apiNamespace        = utils.MustGetEnv("API_NAMESPACE")
        localClientset      kubernetes.Interface
        runClusterInitAsync = true
)

// Config represents the configuration for the API
type Config struct {
        Clusters              []ClusterConfig `yaml:"clusters"`
        AllowedRoles          []models.Roles  `yaml:"allowedRoles"`
        PlatformApproverTeams []models.Team   `yaml:"platformApproverTeams"`
        AdminTeams            []models.Team   `yaml:"adminTeams"`
}

// ClusterConfig represents the configuration for a cluster
type ClusterConfig struct {
        Name        string `yaml:"name"`
        Host        string `yaml:"host"`
        CA          string `yaml:"ca"`
        Insecure    bool   `yaml:"insecure"`
        TokenSecret string `yaml:"tokenSecret"`
        Token       string `yaml:"token"`
        Type        string `yaml:"type"`      // e.g., "gke" or "generic" or "aks"
        ProjectID   string `yaml:"projectID"` // GCP project ID for GKE clusters
        Region      string `yaml:"region"`    // Region for GKE clusters
}

// InitK8sConfig loads clusters, roles and approver teams from configMap into global vars
// and creates a dynamic client for each cluster
// It also loads the kubeconfig from the local file system or in-cluster config
// and creates a local clientset for the API server
// It is called during the initialization of the API in main.go
func InitK8sConfig() <span class="cov8" title="1">{
        var config *rest.Config
        var err error

        CallbackHostOverride = utils.MustGetEnv("CALLBACK_HOST_OVERRIDE")

        // Load in-cluster kube config
        config, err = rest.InClusterConfig()
        if err != nil </span><span class="cov8" title="1">{
                // Load kubeconfig from environment variable
                kubeconfigPath := os.Getenv("KUBECONFIG")
                if kubeconfigPath == "" </span><span class="cov8" title="1">{
                        kubeconfigPath = os.Getenv("HOME") + "/.kube/config"
                }</span>
                <span class="cov8" title="1">config, err = clientcmd.BuildConfigFromFlags("", kubeconfigPath)
                if err != nil </span><span class="cov0" title="0">{
                        panic(err.Error())</span>
                }
        }

        <span class="cov8" title="1">if localClientset == nil </span><span class="cov0" title="0">{
                localClientset, err = kubernetes.NewForConfig(config)
                if err != nil </span><span class="cov0" title="0">{
                        panic(err.Error())</span>
                }
        }

        // Load ConfigMap of clusters from local file system
        <span class="cov8" title="1">configPath := utils.MustGetEnv("CONFIG_MOUNT_PATH")
        configData, err := os.ReadFile(configPath + "/apiConfig.yaml")
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Error reading config file", zap.Error(err))
        }</span>

        // Parse ConfigMap data to global ApiConfig
        <span class="cov8" title="1">err = yaml.Unmarshal([]byte(configData), &amp;ApiConfig)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Error unmarshalling config data", zap.Error(err))
        }</span>

        // Get cluster tokens and add to global cluster maps
        <span class="cov8" title="1">logger.Info("Successfully loaded config for clusters",
                zap.Strings("clusters", ClusterNames),
        )
        for _, cluster := range ApiConfig.Clusters </span><span class="cov8" title="1">{
                logger.Info("Loaded cluster", zap.String("name", cluster.Name), zap.String("type", cluster.Type))
                if cluster.Type == "generic" </span><span class="cov8" title="1">{
                        cluster.Token = getTokenFromSecret(cluster.TokenSecret)
                }</span>
                <span class="cov8" title="1">ClusterConfigs[cluster.Name] = cluster
                ClusterNames = append(ClusterNames, cluster.Name)</span>
        }

        <span class="cov8" title="1">AllowedRoles = ApiConfig.AllowedRoles
        PlatformApproverTeams = ApiConfig.PlatformApproverTeams
        AdminTeams = ApiConfig.AdminTeams

        // Log loaded config
        logger.Info("Allowed roles loaded", zap.Int("count", len(AllowedRoles)))
        for _, role := range AllowedRoles </span><span class="cov8" title="1">{
                logger.Info("Allowed role", zap.String("name", role.Name))
        }</span>
        <span class="cov8" title="1">logger.Info("Approver teams loaded", zap.Int("count", len(PlatformApproverTeams)))
        for _, team := range PlatformApproverTeams </span><span class="cov8" title="1">{
                logger.Info("Approver team", zap.String("name", team.Name), zap.String("id", team.ID))
        }</span>
        <span class="cov8" title="1">logger.Info("Admin teams loaded", zap.Int("count", len(AdminTeams)))
        for _, team := range AdminTeams </span><span class="cov8" title="1">{
                logger.Info("Admin team", zap.String("name", team.Name), zap.String("id", team.ID))
        }</span>

        // Cache dynamic clients for all clusters on startup
        <span class="cov8" title="1">for _, clusterName := range ClusterNames </span><span class="cov8" title="1">{
                req := models.RequestData{ClusterName: clusterName}
                if runClusterInitAsync </span><span class="cov0" title="0">{ // for production
                        go func(r models.RequestData) </span><span class="cov0" title="0">{
                                defer func() </span><span class="cov0" title="0">{
                                        if err := recover(); err != nil </span><span class="cov0" title="0">{
                                                logger.Error("Failed to cache dynamic client for cluster", zap.String("cluster", r.ClusterName), zap.Any("error", err))
                                        }</span>
                                }()
                                <span class="cov0" title="0">createDynamicClient(r)</span>
                        }(req)
                } else<span class="cov8" title="1"> {
                        // for testing
                        createDynamicClient(req)
                }</span>
        }
}

// getTokenFromSecret gets and returns the sa token from a k8s secret during init of kube configs
func getTokenFromSecret(secretName string) string <span class="cov8" title="1">{
        secret, err := localClientset.CoreV1().Secrets(apiNamespace).Get(context.TODO(), secretName, metav1.GetOptions{})
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("Error getting secret", zap.String("secret", secretName), zap.Error(err))
                panic(err.Error())</span>
        }
        <span class="cov8" title="1">return string(secret.Data["token"])</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package k8s

import (
        "context"
        "fmt"
        "kube-jit/internal/models"
        "sync"
        "time"

        "go.uber.org/zap"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

var jitGroupsCache sync.Map

type JitGroup struct {
        GroupID   string `json:"groupID"`
        Namespace string `json:"namespace"`
        GroupName string `json:"groupName"`
}

type JitGroupsCache struct {
        JitGroups *unstructured.Unstructured
        ExpiresAt int64
}

// GetJitGroups fetches the JitGroups from the cluster
// It checks if the cache is valid and returns the cached JitGroups if available
// If the cache is expired or not available, it fetches the JitGroups from the cluster
// and caches it for 10 minutes
var GetJitGroups = func(clusterName string) (*unstructured.Unstructured, error) <span class="cov0" title="0">{
        // Check if the cache exists
        if cached, exists := jitGroupsCache.Load(clusterName); exists </span><span class="cov0" title="0">{
                cache := cached.(*JitGroupsCache)
                currentTime := time.Now().Unix()

                // Check if the cache is still valid
                if cache.ExpiresAt &gt; currentTime </span><span class="cov0" title="0">{
                        logger.Debug("Using cached JitGroups for cluster", zap.String("cluster", clusterName))
                        return cache.JitGroups, nil
                }</span>

                <span class="cov0" title="0">logger.Info("JitGroups cache expired for cluster, refreshing", zap.String("cluster", clusterName))</span>
        }

        // Fetch JitGroups from the cluster
        <span class="cov0" title="0">jitGroups, err := fetchJitGroupsFromCluster(clusterName)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error fetching JitGroups for cluster", zap.String("cluster", clusterName), zap.Error(err))
                return nil, fmt.Errorf("failed to fetch JitGroups for cluster %s", clusterName)
        }</span>

        // Cache the JitGroups with a 10-minute expiration
        <span class="cov0" title="0">expiration := time.Now().Add(10 * time.Minute).Unix()
        jitGroupsCache.Store(clusterName, &amp;JitGroupsCache{
                JitGroups: jitGroups,
                ExpiresAt: expiration,
        })
        logger.Info("Cached JitGroups for cluster", zap.String("cluster", clusterName))
        return jitGroups, nil</span>
}

// fetchJitGroupsFromCluster fetches the JitGroups from the cluster using the dynamic client
// It uses the dynamic client to query the JitGroups CRD
// It returns the JitGroups object or an error if fetching fails
func fetchJitGroupsFromCluster(clusterName string) (*unstructured.Unstructured, error) <span class="cov0" title="0">{
        dynamicClient := createDynamicClient(models.RequestData{ClusterName: clusterName})

        // Query the JitGroups CRD
        jitGroups, err := dynamicClient.Resource(schema.GroupVersionResource{
                Group:    "jit.kubejit.io",
                Version:  "v1",
                Resource: "jitgroupcaches",
        }).Get(context.TODO(), jitgroupcacheName, metav1.GetOptions{}) // Static name for the JitGroupCache object is 'jitgroupcache
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error fetching JitGroups from cluster", zap.String("cluster", clusterName), zap.Error(err))
                return nil, fmt.Errorf("failed to fetch JitGroups for cluster %s", clusterName)
        }</span>
        <span class="cov0" title="0">return jitGroups, nil</span>
}

// InvalidateJitGroupsCache invalidates the JitGroups cache for a specific cluster
var InvalidateJitGroupsCache = func(clusterName string) <span class="cov8" title="1">{
        logger.Info("Invalidating JitGroups cache for cluster", zap.String("cluster", clusterName))
        jitGroupsCache.Delete(clusterName)
}</span>

// ValidateNamespaces checks if the given namespaces are valid for the cluster
// It fetches the JitGroups for the cluster and checks if the namespaces exist in the JitGroups
// It returns a map of namespaces with their corresponding group IDs and names
// or an error if any namespace is invalid
var ValidateNamespaces = func(clusterName string, namespaces []string) (map[string]struct{ GroupID, GroupName string }, error) <span class="cov8" title="1">{
        jitGroups, err := GetJitGroups(clusterName)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("error fetching JitGroups: %v", err)
        }</span>

        <span class="cov8" title="1">namespaceAnnotations := make(map[string]struct{ GroupID, GroupName string })
        groups, _, _ := unstructured.NestedSlice(jitGroups.Object, "spec", "groups")

        for _, namespace := range namespaces </span><span class="cov8" title="1">{
                found := false
                for _, group := range groups </span><span class="cov8" title="1">{
                        groupMap, ok := group.(map[string]interface{})
                        if !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid group format in JitGroups")
                        }</span>
                        <span class="cov8" title="1">jitGroup := JitGroup{}
                        if id, ok := groupMap["groupID"].(string); ok </span><span class="cov8" title="1">{
                                jitGroup.GroupID = id
                        }</span>
                        <span class="cov8" title="1">if ns, ok := groupMap["namespace"].(string); ok </span><span class="cov8" title="1">{
                                jitGroup.Namespace = ns
                        }</span>
                        <span class="cov8" title="1">if name, ok := groupMap["groupName"].(string); ok </span><span class="cov8" title="1">{
                                jitGroup.GroupName = name
                        }</span>
                        <span class="cov8" title="1">if jitGroup.Namespace == namespace </span><span class="cov8" title="1">{
                                namespaceAnnotations[namespace] = struct{ GroupID, GroupName string }{
                                        GroupID:   jitGroup.GroupID,
                                        GroupName: jitGroup.GroupName,
                                }
                                found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("namespace %s does not exist in JitGroups", namespace)
                }</span>
        }
        <span class="cov8" title="1">return namespaceAnnotations, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package k8s

import (
        "go.uber.org/zap"
)

var logger *zap.Logger

func InitLogger(l *zap.Logger) <span class="cov0" title="0">{
        logger = l
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package k8s

import (
        "context"
        "fmt"
        "kube-jit/internal/models"
        "kube-jit/pkg/utils"
        "time"

        "go.uber.org/zap"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

var (
        gvr = schema.GroupVersionResource{
                Group:    "jit.kubejit.io",
                Version:  "v1",
                Resource: "jitrequests",
        }
)

// CreateK8sObject creates the k8s JitRequest object on target cluster
// It uses the dynamic client to create the object
// It takes the request data and approver name as input
// It generates a signed URL for the callback and sets the start and end times
// It returns an error if the creation fails
var CreateK8sObject = func(req models.RequestData, approverName string) error <span class="cov8" title="1">{
        // Generate signed URL for callback
        callbackBaseURL := CallbackHostOverride + "/k8s-callback"
        signedURL, err := utils.GenerateSignedURL(callbackBaseURL, req.EndDate)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("Failed to generate signed URL", zap.Error(err))
                return err
        }</span>

        // Convert []string to []interface{} for unstructured
        <span class="cov8" title="1">namespaces := make([]interface{}, len(req.Namespaces))
        for i, ns := range req.Namespaces </span><span class="cov8" title="1">{
                namespaces[i] = ns
        }</span>
        <span class="cov8" title="1">users := make([]interface{}, len(req.Users))
        for i, u := range req.Users </span><span class="cov8" title="1">{
                users[i] = u
        }</span>

        // jitRequest payload
        <span class="cov8" title="1">jitRequest := &amp;unstructured.Unstructured{
                Object: map[string]interface{}{
                        "apiVersion": "jit.kubejit.io/v1",
                        "kind":       "JitRequest",
                        "metadata": map[string]interface{}{
                                "name": fmt.Sprintf("jit-%d", req.ID),
                        },
                        "spec": map[string]interface{}{
                                "user":           req.Username,
                                "approver":       approverName,
                                "justification":  req.Justification,
                                "userEmails":     users,
                                "requestorEmail": req.Email,
                                "clusterRole":    req.RoleName,
                                "namespaces":     namespaces,
                                "ticketID":       fmt.Sprintf("%d", req.ID),
                                "startTime":      req.StartDate.Format(time.RFC3339),
                                "endTime":        req.EndDate.Format(time.RFC3339),
                                "callbackUrl":    signedURL,
                        },
                },
        }

        // Create client for selected cluster
        dynamicClient := createDynamicClient(req)

        // Create jitRequest
        logger.Info("Creating k8s object for request", zap.Uint("requestID", req.ID))
        _, err = dynamicClient.Resource(gvr).Create(context.TODO(), jitRequest, metav1.CreateOptions{})
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("Error creating k8s object for request", zap.Uint("requestID", req.ID), zap.Error(err))
                return err
        }</span>
        <span class="cov8" title="1">logger.Info("Successfully created k8s object for request", zap.Uint("requestID", req.ID))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package sessioncookie

import (
        "go.uber.org/zap"
)

var (
        logger *zap.Logger
)

func InitLogger(l *zap.Logger) <span class="cov0" title="0">{
        logger = l
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package sessioncookie

import (
        "encoding/json"
        "fmt"
        "kube-jit/pkg/utils"
        "net/http"
        "strings"

        "github.com/gin-contrib/sessions"
        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
)

const maxCookieSize = 4000                // Max size for a single cookie
const SessionPrefix = "kube_jit_session_" // Prefix for session cookies to handle split into multiple cookies

// SplitAndCombineSessionMiddleware handles splitting and combining session cookies
// It combines session data from multiple cookies into one session and splits it back into multiple cookies if necessary
// after processing the request.
// This is useful for handling large session data that exceeds the cookie size limit.
func SplitAndCombineSessionMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Combine session data from multiple cookies
                CombineSessionData(c)

                // Process the request
                c.Next()

                // Split session data into multiple cookies if necessary
                SplitSessionData(c)
        }</span>
}

// CombineSessionData combines session data from multiple cookies
// into a single session object. It reads the cookies with the session prefix,
// decodes the data, and sets it in the session.
func CombineSessionData(c *gin.Context) <span class="cov0" title="0">{
        var combinedData strings.Builder

        // Iterate through cookies with the session prefix
        for i := 0; ; i++ </span><span class="cov0" title="0">{
                cookieName := fmt.Sprintf("%s%d", SessionPrefix, i)
                chunk, err := c.Cookie(cookieName)
                if err != nil </span><span class="cov0" title="0">{
                        break</span> // Stop when no more cookies are found
                }
                <span class="cov0" title="0">combinedData.WriteString(chunk)</span>
        }

        // Decode the combined session data
        <span class="cov0" title="0">if combinedData.Len() &gt; 0 </span><span class="cov0" title="0">{
                var decodedData string
                err := decodeSessionData("session_data", combinedData.String(), &amp;decodedData)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to decode session data", zap.Error(err))
                        return
                }</span>

                // Check if the decoded data is valid JSON
                <span class="cov0" title="0">if !json.Valid([]byte(decodedData)) </span><span class="cov0" title="0">{
                        logger.Error("Decoded session data is not valid JSON")
                        return
                }</span>

                // Deserialize the JSON string into a map
                <span class="cov0" title="0">var sessionData map[string]interface{}
                err = json.Unmarshal([]byte(decodedData), &amp;sessionData)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to deserialize session data", zap.Error(err))
                        return
                }</span>

                // Set the combined session data in the session
                <span class="cov0" title="0">session := sessions.Default(c)
                session.Set("data", sessionData)</span>
        }
}

// SplitSessionData splits session data into multiple cookies if necessary
// and sets them in the response. It also deletes any leftover cookies from previous sessions.
// This is useful for handling large session data that exceeds the cookie size limit.
func SplitSessionData(c *gin.Context) <span class="cov0" title="0">{
        session := sessions.Default(c)
        data := session.Get("data")
        if data == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Serialize session data to JSON
        <span class="cov0" title="0">sessionDataJSON, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to serialize session data", zap.Error(err))
                return
        }</span>

        // Encode the session data
        <span class="cov0" title="0">encodedData, err := encodeSessionData("session_data", string(sessionDataJSON))
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to encode session data", zap.Error(err))
                return
        }</span>

        // Split the encoded data into smaller chunks
        <span class="cov0" title="0">chunks := splitIntoChunks(encodedData, maxCookieSize)

        // Set the cookies for each chunk
        for i, chunk := range chunks </span><span class="cov0" title="0">{
                cookieName := fmt.Sprintf("%s%d", SessionPrefix, i)

                sameSiteEnv := utils.GetEnv("COOKIE_SAMESITE", "Lax")
                var sameSite http.SameSite
                switch sameSiteEnv </span>{
                case "Strict":<span class="cov0" title="0">
                        sameSite = http.SameSiteStrictMode</span>
                case "None":<span class="cov0" title="0">
                        sameSite = http.SameSiteNoneMode</span>
                default:<span class="cov0" title="0">
                        sameSite = http.SameSiteLaxMode</span>
                }

                <span class="cov0" title="0">http.SetCookie(c.Writer, &amp;http.Cookie{
                        Name:     cookieName,
                        Value:    chunk,
                        Path:     "/",
                        HttpOnly: true,
                        Secure:   true,
                        MaxAge:   3600, // Set cookie expiration time
                        SameSite: sameSite,
                })</span>
        }

        // Delete any leftover cookies from previous sessions
        <span class="cov0" title="0">for i := len(chunks); ; i++ </span><span class="cov0" title="0">{
                cookieName := fmt.Sprintf("%s%d", SessionPrefix, i)
                _, err := c.Cookie(cookieName)
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">http.SetCookie(c.Writer, &amp;http.Cookie{
                        Name:     cookieName,
                        Value:    "",
                        Path:     "/",
                        HttpOnly: true,
                        Secure:   true,
                        MaxAge:   -1, // Delete the cookie
                })</span>
        }
}

// splitIntoChunks splits a string into chunks of a specified size
// and returns a slice of the chunks.
func splitIntoChunks(data string, chunkSize int) []string <span class="cov8" title="1">{
        var chunks []string
        for len(data) &gt; chunkSize </span><span class="cov8" title="1">{
                chunks = append(chunks, data[:chunkSize])
                data = data[chunkSize:]
        }</span>
        <span class="cov8" title="1">chunks = append(chunks, data)
        return chunks</span>
}

// encodeSessionData encodes session data using securecookie.
// It uses the securecookie library to encode the data into a string format.
// It returns an error if the encoding fails.
// The encoded data can be stored in a cookie.
func encodeSessionData(name string, value interface{}) (string, error) <span class="cov8" title="1">{
        encoded, err := utils.SecureCookie().Encode(name, value)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to encode session data", zap.Error(err))
                return "", fmt.Errorf("failed to encode session data: %v", err)
        }</span>
        <span class="cov8" title="1">return encoded, nil</span>
}

// decodeSessionData decodes session data using securecookie.
// It uses the securecookie library to decode the data from a string format.
// It returns an error if the decoding fails.
// The decoded data can be used to retrieve the original session data.
func decodeSessionData(name, encodedValue string, dst interface{}) error <span class="cov8" title="1">{
        err := utils.SecureCookie().Decode(name, encodedValue, dst)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to decode session data", zap.Error(err))
                return fmt.Errorf("failed to decode session data: %v", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package utils

import (
        "crypto/hmac"
        "crypto/sha256"
        "encoding/hex"
        "fmt"
        "net/url"
        "strconv"
        "time"

        "go.uber.org/zap"
)

var (
        hmacKey = MustGetEnv("HMAC_SECRET") // HMAC key for signing URLs
)

// GenerateSignedURL creates a signed url with hmac key based on expiry
// It takes a base URL and an expiry time as input and returns the signed URL
// or an error if the URL cannot be generated.
var GenerateSignedURL = func(baseURL string, expiryTime time.Time) (string, error) <span class="cov8" title="1">{
        u, err := url.Parse(baseURL)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("Failed to parse base URL for signed URL", zap.Error(err))
                return "", err
        }</span>

        <span class="cov8" title="1">query := u.Query()
        query.Set("expiry", fmt.Sprintf("%d", expiryTime.Unix()))
        u.RawQuery = query.Encode()

        // Encode the URL before generating the HMAC signature
        encodedURL := u.String()
        signature := GenerateHMAC(encodedURL)

        query.Set("signature", signature)
        u.RawQuery = query.Encode()

        return u.String(), nil</span>
}

// GenerateHMAC creates/returns hash string
// It takes a string as input and returns the HMAC hash as a hexadecimal string.
func GenerateHMAC(data string) string <span class="cov8" title="1">{
        key := []byte(hmacKey)
        h := hmac.New(sha256.New, key)
        h.Write([]byte(data))
        return hex.EncodeToString(h.Sum(nil))
}</span>

// ValidateSignedURL returns true/false if a url matches the hmac sig
// It takes a signed URL as input and validates its expiry time and signature.
// It returns true if the URL is valid and not expired, false otherwise.
func ValidateSignedURL(u *url.URL, _ string) bool <span class="cov8" title="1">{
        query := u.Query()
        expiry := query.Get("expiry")
        signature := query.Get("signature")

        // Check if the URL has expired
        expiryTime, err := strconv.ParseInt(expiry, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn("Failed to parse expiry time in signed URL", zap.Error(err))
                return false
        }</span>

        <span class="cov8" title="1">currentTime := time.Now().Unix()
        if currentTime &gt; expiryTime </span><span class="cov8" title="1">{
                logger.Warn("Signed URL has expired")
                return false
        }</span>

        // Remove the signature from the query parameters
        <span class="cov8" title="1">query.Del("signature")
        u.RawQuery = query.Encode()

        // Use the actual callback URL (minus signature) for validation
        encodedURL := u.String()
        expectedSignature := GenerateHMAC(encodedURL)

        logger.Debug("Validating signed URL",
                zap.String("expectedSignature", expectedSignature),
                zap.String("providedSignature", signature),
                zap.String("signedString", encodedURL),
        )

        if !hmac.Equal([]byte(expectedSignature), []byte(signature)) </span><span class="cov8" title="1">{
                logger.Warn("Invalid signature in signed URL")
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package utils

import (
        "go.uber.org/zap"
)

var (
        logger *zap.Logger
)

// InitLogger sets the zap logger for this package
func InitLogger(l *zap.Logger) <span class="cov0" title="0">{
        logger = l
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package utils

import (
        "sync"

        "github.com/gorilla/securecookie"
)

var (
        secureCookieInstance *securecookie.SecureCookie
        once                 sync.Once // Ensure that the SecureCookie instance is created only once
)

// SecureCookie returns a singleton instance of securecookie.SecureCookie
// It uses the HMAC_SECRET environment variable for the secret key
// and sets the maximum length for the cookie to 16384 bytes.
// Uses sync.Once to ensure that the instance is created only once.
func SecureCookie() *securecookie.SecureCookie <span class="cov8" title="1">{
        once.Do(func() </span><span class="cov8" title="1">{
                secret := MustGetEnv("HMAC_SECRET")
                secureCookieInstance = securecookie.New([]byte(secret), nil)
                secureCookieInstance.MaxLength(16384)
        }</span>)
        <span class="cov8" title="1">return secureCookieInstance</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package utils

import (
        "os"

        "go.uber.org/zap"
)

// MustGetEnv returns the value of the environment variable or logs fatal and exits if not set
func MustGetEnv(key string) string <span class="cov8" title="1">{
        val := os.Getenv(key)
        if val == "" </span><span class="cov8" title="1">{
                if logger != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Missing required environment variable", zap.String("key", key))
                }</span> else<span class="cov8" title="1"> {
                        panic("Missing required environment variable: " + key)</span>
                }
        }
        <span class="cov8" title="1">return val</span>
}

// GetEnv reads an environment variable or returns a default value if not set
func GetEnv(key, defaultValue string) string <span class="cov8" title="1">{
        if value, exists := os.LookupEnv(key); exists </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov8" title="1">return defaultValue</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
